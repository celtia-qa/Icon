{
  "openapi": "3.0.0",
  "info": {
    "title": "HumanFirst API",
    "version": "0.0.1"
  },
  "paths": {
    "/v1alpha1/conversation_sets": {
      "get": {
        "summary": "ListConversationSets",
        "operationId": "ConversationSetStore_ListConversationSets",
        "parameters": [
          {
            "name": "namespace",
            "in": "query",
            "description": "Namespace in which conversation sets to be listed are.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListConversationSetsResponse"
                }
              }
            }
          }
        },
        "description": "Lists conversation sets that can be used by a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sets/{namespace}": {},
    "/v1alpha1/conversation_sets/{namespace}/{id}": {
      "get": {
        "summary": "GetConversationSet",
        "operationId": "ConversationSetStore_GetConversationSet",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which conversation set is.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "Unique identifier of the conversation set.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationSet"
                }
              }
            }
          }
        },
        "description": "Returns a specific conversation set that can be used by a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sets/{namespace}/{id}/acl": {},
    "/v1alpha1/conversation_sets/{namespace}/{id}/config": {},
    "/v1alpha1/conversation_sets/{namespace}/{id}/state": {},
    "/v1alpha1/conversation_sets/{namespace}:link": {
      "post": {
        "summary": "LinkConversationSets",
        "operationId": "ConversationSetStore_LinkConversationSets",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which conversation sets and workspace are.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LinkConversationSetsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkConversationSetsResponse"
                }
              }
            }
          }
        },
        "description": "Link conversation sets to a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sets/{namespace}:unlink": {
      "post": {
        "summary": "UnlinkConversationSets",
        "operationId": "ConversationSetStore_UnlinkConversationSets",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which conversation sets and workspace are.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnlinkConversationSetsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnlinkConversationSetsResponse"
                }
              }
            }
          }
        },
        "description": "Unlink conversation sets from a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sources": {
      "get": {
        "summary": "ListConversationSources",
        "operationId": "ConversationSourceStore_ListConversationSources",
        "parameters": [
          {
            "name": "namespace",
            "in": "query",
            "description": "Namespace in which conversation sources to list are.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListConversationSourcesResponse"
                }
              }
            }
          }
        },
        "description": "Lists configured sources of conversations.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sources/{namespace}": {},
    "/v1alpha1/conversation_sources/{namespace}/{id}": {
      "get": {
        "summary": "GetConversationSource",
        "operationId": "ConversationSourceStore_GetConversationSource",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which conversation source is.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "Unique identifier of the conversation source.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationSource"
                }
              }
            }
          }
        },
        "description": "Returns a specific configured source of conversations.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/conversation_sources/{namespace}/{id}/acl": {},
    "/v1alpha1/conversation_sources/{namespace}/{id}/state": {},
    "/v1alpha1/files/{namespace}/{conversation_source_id}": {
      "post": {
        "summary": "ImportConversationsFile",
        "description": "Import unlabelled conversational files into a conversation source using a multipart request.",
        "operationId": "Data_ImportConversationsFile",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace where the conversation source is located.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "conversation_source_id",
            "in": "path",
            "description": "Unique identifier of the conversation source in which we want to import the file.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "file": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    },
                    "description": "(multi-part) content of the file in specified format"
                  },
                  "format": {
                    "type": "string",
                    "description": "(multi-part) format of the file. Possible formats: <br/> <ul><li>IMPORT_FORMAT_SIMPLE_CSV</li><li>IMPORT_FORMAT_UTTERANCES_TXT</li><li>IMPORT_FORMAT_RASA_EVENTS_JSONL</li><li>IMPORT_FORMAT_HUMANFIRST_JSON</li></ul>"
                  },
                  "column_mapper_options": {
                    "$ref": "#/components/schemas/ColumnMapperOptions"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportConversationsFileResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/files/{namespace}/{conversation_source_id}/export": {
      "post": {
        "summary": "ExportConversationsFile",
        "operationId": "Data_ExportConversationsFile",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "conversation_source_id",
            "in": "path",
            "description": "Unique identifier of the conversation source in which we want to export files from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportConversationsFileRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportConversationsFileResponse"
                }
              }
            }
          }
        },
        "description": "Export unlabelled conversational files from a conversation source.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/files/{namespace}/{conversation_source_id}/{filename}": {
      "delete": {
        "summary": "DeleteConversationsFile",
        "operationId": "Data_DeleteConversationsFile",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "conversation_source_id",
            "in": "path",
            "description": "Unique identifier of the conversation source in which we want to import the file.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filename",
            "in": "path",
            "description": "Name of the file to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteConversationsFileRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteConversationsFileResponse"
                }
              }
            }
          }
        },
        "description": "Delete an unlabelled conversational file from a conversation source.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/integrations/{integration_id}/analyze_integration_import": {
      "post": {
        "summary": "AnalyzeIntegrationDataImport",
        "operationId": "Data_AnalyzeIntegrationDataImport",
        "parameters": [
          {
            "name": "integration_id",
            "in": "path",
            "description": "Id of the integration.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnalyzeIntegrationDataImportRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnalyzeIntegrationDataImportResponse"
                }
              }
            }
          }
        },
        "description": "Analyze a data import job. Useful to known the schema of the data and catch some errors before importing.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/integrations/{integration_id}/import_from_integration": {
      "post": {
        "summary": "ImportDataFromIntegration",
        "operationId": "Data_ImportDataFromIntegration",
        "parameters": [
          {
            "name": "integration_id",
            "in": "path",
            "description": "Id of the integration.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImportDataFromIntegrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportDataFromIntegrationResponse"
                }
              }
            }
          }
        },
        "description": "Import from an integration.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/nlu/predict/{namespace}/{playbook_id}": {
      "post": {
        "summary": "Predict",
        "operationId": "NLU_Predict",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace where the workspace is located.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace whose model is to be used.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PredictRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PredictResponse"
                }
              }
            }
          }
        },
        "description": "Predicts the intents associated with a given input utterance.",
        "tags": [
          "NLU"
        ]
      }
    },
    "/v1alpha1/nlu/predict/{namespace}/{playbook_id}/batch": {
      "post": {
        "summary": "BatchPredict",
        "operationId": "NLU_BatchPredict",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace where the workspace is located.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace whose model is to be used.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchPredictRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchPredictResponse"
                }
              }
            }
          }
        },
        "description": "Predicts the intents associated with a batch of utterances.",
        "tags": [
          "NLU"
        ]
      }
    },
    "/v1alpha1/playbooks": {
      "get": {
        "summary": "ListWorkspaces",
        "operationId": "PlaybookStore_ListPlaybooks",
        "parameters": [
          {
            "name": "namespace",
            "in": "query",
            "description": "Namespace from which workspaces are listed.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPlaybooksResponse"
                }
              }
            }
          }
        },
        "description": "Lists workspaces in a namespace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}": {},
    "/v1alpha1/playbooks/{namespace}/{id}": {
      "get": {
        "summary": "GetWorkspace",
        "operationId": "PlaybookStore_GetPlaybook",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the workspace is.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "Unique identifier of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Playbook"
                }
              }
            }
          }
        },
        "description": "Returns a single workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{id}/acl": {},
    "/v1alpha1/playbooks/{namespace}/{id}/state": {},
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/ephemeral-pipeline:trigger": {},
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/nlg_generation_runs": {},
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/nlu_engines": {
      "get": {
        "summary": "ListPlaybookNluEngines",
        "operationId": "PlaybookStore_ListPlaybookNluEngines",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the nlu engines are.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the nlu engines are.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPlaybookNluEnginesResponse"
                }
              }
            }
          }
        },
        "description": "Lists nlu engines in a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/nlu_engines/{nlu_id}": {
      "get": {
        "summary": "GetPlaybookNluEngine",
        "operationId": "PlaybookStore_GetPlaybookNluEngine",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the nlu engine is.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the nlu engine is.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "nlu_id",
            "in": "path",
            "description": "Unique identifier of the nlu engine.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NluSettings"
                }
              }
            }
          }
        },
        "description": "Returns a single nlu engine object.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/pipelines": {
      "get": {
        "summary": "ListPlaybookPipelines",
        "operationId": "PlaybookStore_ListPlaybookPipelines",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the pipelines exist.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the pipelines exist.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPlaybookPipelinesResponse"
                }
              }
            }
          }
        },
        "description": "Lists pipelines in a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/pipelines/{pipeline_id}": {
      "get": {
        "summary": "GetPlaybookPipeline",
        "operationId": "PlaybookStore_GetPlaybookPipeline",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the pipeline exists.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the pipeline exists.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pipeline_id",
            "in": "path",
            "description": "Unique identifier of the pipeline.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pipeline"
                }
              }
            }
          }
        },
        "description": "Returns a single pipeline object.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/pipelines/{pipeline_id}:trigger": {},
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/presets": {
      "get": {
        "summary": "ListPlaybookPresets",
        "operationId": "PlaybookStore_ListPlaybookPresets",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the presets exist.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the presets exist.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPlaybookPresetsResponse"
                }
              }
            }
          }
        },
        "description": "Lists presets in a workspace.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/playbooks/{namespace}/{playbook_id}/presets/{preset_id}": {
      "get": {
        "summary": "GetPlaybookPreset",
        "operationId": "PlaybookStore_GetPlaybookPreset",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace in which the preset exists.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace in which the preset exists.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "preset_id",
            "in": "path",
            "description": "Unique identifier of the preset.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Preset"
                }
              }
            }
          }
        },
        "description": "Returns a single preset object.",
        "tags": [
          "Workspaces"
        ]
      }
    },
    "/v1alpha1/triggers/{namespace}": {
      "get": {
        "operationId": "Triggers_ListTriggers",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the triggers to list.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "object_id",
            "in": "query",
            "description": "Unique identifier of the object to watch triggers for (i.e. playbook, conversation set).",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTriggersResponse"
                }
              }
            }
          }
        },
        "description": "ListTriggers",
        "tags": [],
        "summary": "ListTriggers"
      }
    },
    "/v1alpha1/triggers/{namespace}/{trigger_id}": {
      "get": {
        "operationId": "Triggers_DescribeTrigger",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the trigger.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trigger_id",
            "in": "path",
            "description": "Unique identifier of the trigger.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeTriggerResponse"
                }
              }
            }
          }
        },
        "description": "DescribeTrigger",
        "tags": [],
        "summary": "DescribeTrigger"
      }
    },
    "/v1alpha1/triggers/{namespace}/{trigger_id}:cancel": {
      "post": {
        "operationId": "Triggers_CancelTrigger",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the trigger.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trigger_id",
            "in": "path",
            "description": "Unique identifier of the trigger.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelTriggerResponse"
                }
              }
            }
          }
        },
        "description": "CancelTrigger",
        "tags": [],
        "summary": "CancelTrigger"
      }
    },
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/coverage/latest": {
      "get": {
        "operationId": "Coverage_GetIntentsCoverage",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "model_id",
            "in": "query",
            "description": "Specifies for which model the coverage is requested, specified by its unique NLU engine identifier. If not specified, the default model is used.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "data_selection",
            "in": "query",
            "description": "Specifies the data for which the coverage is requested. If unspecified, the `default_coverage_data` value from the workspace is used.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetIntentsCoverageResponse"
                }
              }
            }
          }
        },
        "description": "GetIntentsCoverage",
        "summary": "GetIntentsCoverage"
      }
    },
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/coverage/latest/export": {
      "get": {
        "operationId": "Coverage_ExportIntentsCoverage",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "model_id",
            "in": "query",
            "description": "The model for which the coverage is requested, specified by its unique NLU engine identifier. If not specified, the default model is used.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "coverage_type",
            "in": "query",
            "description": "Specifies the coverage type of the coverage report.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "confidence_threshold",
            "in": "query",
            "description": "Confidence threshold to use when computing the coverage.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "data_selection",
            "in": "query",
            "description": "Specifies the data for which the coverage is requested. If unspecified, the `default_coverage_data` value from the workspace is used.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HttpBody"
                }
              }
            }
          }
        },
        "description": "ExportIntentsCoverage",
        "summary": "ExportIntentsCoverage"
      }
    },
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/intents/export": {
      "post": {
        "summary": "ExportIntents",
        "operationId": "Data_ExportIntents",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportIntentsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportIntentsResponse"
                }
              }
            }
          }
        },
        "description": "Exports intents of a workspace.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/intents/export_http": {},
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/intents/import": {
      "post": {
        "summary": "ImportIntents",
        "operationId": "Data_ImportIntents",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ImportIntentsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportIntentsResponse"
                }
              }
            }
          }
        },
        "description": "Imports intents into a workspace.",
        "tags": [
          "Import / Export"
        ]
      }
    },
    "/v1alpha1/workspaces/{namespace}/{playbook_id}/intents/import_http": {
      "post": {
        "summary": "ImportIntentsHttp",
        "description": "Imports intents into a workspace using a multipart request.",
        "operationId": "Data_ImportIntentsHttp",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "playbook_id",
            "in": "path",
            "description": "Unique identifier of the workspace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "file": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    },
                    "description": "(multi-part) content of the file in specified format"
                  },
                  "format": {
                    "type": "string",
                    "description": "(multi-part) format of the file. Possible formats: <br/> <ul><li>INTENTS_FORMAT_CSV_SIMPLE_INTENTS</li><li>INTENTS_FORMAT_RASA_MARKDOWN</li><li>INTENTS_FORMAT_RASA_YAML</li><li>INTENTS_FORMAT_DIALOGFLOW_ES_AGENT</li><li>INTENTS_FORMAT_TXT_PHRASES</li><li>INTENTS_FORMAT_HF_JSON</li><li>INTENTS_FORMAT_COGNIGY_JSON</li></ul>"
                  },
                  "request": {
                    "$ref": "#/components/schemas/ImportIntentsRequest",
                    "description": "(multi-part) Optional request body in which all fields, except file and format, can be defined."
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportIntentsResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Import / Export"
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AnalyzeIntegrationDataImportRequest": {
        "title": "AnalyzeIntegrationDataImportRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "integration_id": {
            "type": "string",
            "description": "Id of the integration."
          },
          "params": {
            "$ref": "#/components/schemas/IntegrationDataImportParams"
          },
          "return_data_sample": {
            "type": "boolean",
            "description": "Return up to five rows of data."
          }
        }
      },
      "AnalyzeIntegrationDataImportResponse": {
        "title": "AnalyzeIntegrationDataImportResponse",
        "properties": {
          "field_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Names of the fields. The length of the list will equal the length of the items field."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Item"
            },
            "description": "If the return_data_sample field was true in the request, this field will contain up to five items."
          },
          "problem": {
            "$ref": "#/components/schemas/ValidationProblem"
          },
          "item_count": {
            "type": "integer",
            "description": "Number of items that will get imported.",
            "format": "uint32"
          }
        }
      },
      "Any": {
        "title": "Any",
        "properties": {
          "type_url": {
            "type": "string",
            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
          },
          "value": {
            "type": "string",
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "bytes"
          }
        },
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
      },
      "BatchActions": {
        "title": "BatchActions",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          }
        }
      },
      "BatchPredictRequest": {
        "title": "BatchPredictRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace where the workspace is located."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace whose model is to be used."
          },
          "input_utterances": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Utterances to classify."
          },
          "model_id": {
            "type": "string",
            "description": "Optional. Specifies which model to use through its unique NLU engine identifier. If none specified, the default is used."
          },
          "revision_id": {
            "type": "string",
            "description": "Optional. Specifies which revision of the model to use."
          },
          "intent_tags": {
            "$ref": "#/components/schemas/TagPredicate"
          }
        }
      },
      "BatchPredictResponse": {
        "title": "BatchPredictResponse",
        "properties": {
          "predictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PredictResponse"
            },
            "description": "Predictions for each utterances given in the request. The order is guaranteed to be the same as in the request."
          }
        }
      },
      "Bool": {
        "title": "Bool",
        "properties": {
          "not_stored": {
            "type": "boolean"
          }
        }
      },
      "BoolValue": {
        "title": "BoolValue",
        "properties": {
          "value": {
            "type": "boolean",
            "description": "The bool value."
          }
        },
        "description": "Wrapper message for `bool`. The JSON representation for `BoolValue` is JSON `true` and `false`."
      },
      "Botpress": {
        "title": "Botpress",
        "properties": {}
      },
      "CancelTriggerResponse": {
        "title": "CancelTriggerResponse",
        "properties": {}
      },
      "Cognigy": {
        "title": "Cognigy",
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "see etl/cognigy/objects.go"
          },
          "confirmation_sentences": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "condition": {
            "type": "string"
          },
          "disambiguationSentence": {
            "type": "string"
          },
          "child_features": {
            "type": "boolean"
          },
          "entry_point": {
            "type": "string"
          },
          "is_reject_intent": {
            "type": "boolean"
          },
          "is_disabled": {
            "type": "boolean"
          },
          "override_intent_default_replies_as_examples": {
            "type": "string"
          }
        }
      },
      "ColumnMapperOptions": {
        "title": "ColumnMapperOptions",
        "properties": {
          "header_included": {
            "type": "boolean",
            "description": "If true, the first row is considered as a header and will be ignored."
          },
          "import_as_utterances": {
            "type": "boolean",
            "description": "If true, import as utterances instead of conversations. Default is false."
          },
          "id_column": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "date_column": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "date_format": {
            "type": "integer",
            "description": "Date format of the date field. Default is a UNIX timestamp in milliseconds.",
            "format": "enum"
          },
          "source_column": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "client_name": {
            "type": "string",
            "description": "Source values for the source field. Default is \"client\" and \"agent\"."
          },
          "agent_name": {
            "type": "string"
          },
          "text_column": {
            "type": "integer",
            "description": "Column index to use for the text field.",
            "format": "uint32"
          },
          "metadata_columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CsvColumn"
            },
            "description": "Columns to use for metadata. CSV header must be present."
          },
          "tag_list_column": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "tag_columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CsvColumn"
            },
            "description": "If defined, tag utterances using the column name has the tag name if the value is true. CSV header must be present."
          },
          "delimiter": {
            "type": "string",
            "description": "Delimiter used in the CSV file. This needs to be a single unicode character. If not specified, the default is a comma."
          }
        }
      },
      "ComplexSynonym": {
        "title": "ComplexSynonym",
        "properties": {
          "value": {
            "type": "string",
            "description": "Value / text of the synonym"
          },
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputEntity"
            },
            "description": "(Optional) Entities annotated in the `value`. This is used when the entity is a composed entity that references other entities (composite entities) If the `parts` field is provided on creation or update, this field is ignored and rebuilt from `parts`."
          },
          "parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputPart"
            },
            "description": "(Optional) Parts of the text and the entities. This is used when the entity is a composed entity that references other entities (composite entities). The parts are concatenated to form the final text. Parts are provided to ease entity annotations."
          },
          "position": {
            "type": "integer",
            "description": "The position occupied by the synonym under its parent entity value.",
            "format": "uint32"
          }
        },
        "description": "Complex form of a synonym."
      },
      "Context": {
        "title": "Context",
        "properties": {
          "id": {
            "type": "string",
            "description": "UUID"
          },
          "type": {
            "type": "integer",
            "description": "The type of intents contained by this context",
            "format": "enum"
          },
          "position": {
            "type": "integer",
            "description": "The position occupied by the intent in the current context. (only populated when fetching intents)",
            "format": "uint32"
          },
          "created_at": {
            "type": "string",
            "format": "RFC3339"
          }
        }
      },
      "ConversationSet": {
        "title": "ConversationSet",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the conversation set."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation set generated by the server."
          },
          "name": {
            "type": "string",
            "description": "User visible given name of the conversation set."
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Source"
            },
            "description": "Sources of conversations this conversation set is sourced from."
          },
          "preprocessors": {
            "$ref": "#/components/schemas/ConversationSetPreprocessors"
          }
        },
        "description": "Defines a logical set of conversations representing filtered and converted conversations from an external [ConversationSource]"
      },
      "ConversationSetConfiguration": {
        "title": "ConversationSetConfiguration",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Source"
            }
          }
        },
        "description": "High level configuration of a ConversationSet used to expose higher level abstractions to users."
      },
      "ConversationSetPreprocessors": {
        "title": "ConversationSetPreprocessors",
        "properties": {
          "processors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Processor"
            }
          }
        }
      },
      "ConversationSetsLink": {
        "title": "ConversationSetsLink",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "conversation_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversationSetReference"
            }
          }
        }
      },
      "ConversationSetsUnlink": {
        "title": "ConversationSetsUnlink",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "conversation_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversationSetReference"
            }
          }
        }
      },
      "ConversationSource": {
        "title": "ConversationSource",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the conversation source."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation source generated by the server."
          },
          "name": {
            "type": "string",
            "description": "User visible given name of the conversation source."
          }
        },
        "description": "Defines an upstream dataset synchronized to our pipeline Defining this object starts synchronizing all available data"
      },
      "ConversationsFileDelete": {
        "title": "ConversationsFileDelete",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          }
        }
      },
      "ConversationsFileImport": {
        "title": "ConversationsFileImport",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          }
        }
      },
      "CreateConversationSetRequest": {
        "title": "CreateConversationSetRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation set is."
          },
          "conversation_set": {
            "$ref": "#/components/schemas/ConversationSet"
          },
          "source": {
            "$ref": "#/components/schemas/ConversationSource"
          }
        }
      },
      "CreateConversationSourceRequest": {
        "title": "CreateConversationSourceRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation source is."
          },
          "conversation_source": {
            "$ref": "#/components/schemas/ConversationSource"
          }
        }
      },
      "CreateEntityRequest": {
        "title": "CreateEntityRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          }
        }
      },
      "CreateEntityResponse": {
        "title": "CreateEntityResponse",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/Entity"
          }
        }
      },
      "CreateEntityValueRequest": {
        "title": "CreateEntityValueRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID of the entity value to update"
          },
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          },
          "position": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        }
      },
      "CreateEntityValueResponse": {
        "title": "CreateEntityValueResponse",
        "properties": {
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          }
        }
      },
      "CreateIntentRequest": {
        "title": "CreateIntentRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent": {
            "$ref": "#/components/schemas/Intent"
          }
        }
      },
      "CreatePlaybookNluEngineRequest": {
        "title": "CreatePlaybookNluEngineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the nlu engine is."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the nlu engine is."
          },
          "nlu_engine": {
            "$ref": "#/components/schemas/NluSettings"
          }
        }
      },
      "CreatePlaybookPipelineRequest": {
        "title": "CreatePlaybookPipelineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the pipeline exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the pipeline exists."
          },
          "pipeline": {
            "$ref": "#/components/schemas/Pipeline"
          }
        }
      },
      "CreatePlaybookPresetRequest": {
        "title": "CreatePlaybookPresetRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the preset exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the preset exists."
          },
          "preset": {
            "$ref": "#/components/schemas/Preset"
          }
        }
      },
      "CreatePlaybookRequest": {
        "title": "CreatePlaybookRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the workspace is."
          },
          "playbook": {
            "$ref": "#/components/schemas/Playbook"
          },
          "exclude_nlu_engines": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to nlu engines."
          },
          "exclude_presets": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to presets."
          },
          "exclude_pipelines": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to pipelines."
          }
        }
      },
      "CreateTagRequest": {
        "title": "CreateTagRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "tag": {
            "$ref": "#/components/schemas/Tag"
          }
        }
      },
      "CreateTagResponse": {
        "title": "CreateTagResponse",
        "properties": {
          "tag": {
            "$ref": "#/components/schemas/Tag"
          }
        }
      },
      "CreateTrainingPhraseRequest": {
        "title": "CreateTrainingPhraseRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent_id": {
            "type": "string",
            "description": "ID of the intent to add phrase to"
          },
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          }
        }
      },
      "CreateTrainingPhraseResponse": {
        "title": "CreateTrainingPhraseResponse",
        "properties": {
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          }
        }
      },
      "CsvColumn": {
        "title": "CsvColumn",
        "properties": {
          "index": {
            "type": "integer",
            "format": "uint32"
          },
          "name_overwrite": {
            "type": "string",
            "description": "If not empty, this name will replace the column's name."
          }
        }
      },
      "DataEntry": {
        "title": "DataEntry",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/JobTriggerData"
          }
        }
      },
      "DataQuery": {
        "title": "DataQuery",
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Query"
            },
            "description": "The queries to be used by the step."
          },
          "max_processed_items": {
            "type": "integer",
            "description": "The maximum number of items to be processed from the query.",
            "format": "uint32"
          }
        }
      },
      "DeleteConversationsFileRequest": {
        "title": "DeleteConversationsFileRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Unique identifier of the conversation source in which we want to import the file."
          },
          "filename": {
            "type": "string",
            "description": "Name of the file to delete."
          },
          "no_trigger": {
            "type": "boolean",
            "description": "Don't trigger the pipeline after deleting the file. This will not process the file deletion, but it will be processed on the next trigger."
          }
        }
      },
      "DeleteConversationsFileResponse": {
        "title": "DeleteConversationsFileResponse",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline trigger that was created when deleting the file. This may be empty if the `no_trigger` field was set to true."
          }
        }
      },
      "DeleteEntityReferencesRequest": {
        "title": "DeleteEntityReferencesRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity_id": {
            "type": "string",
            "description": "(Optional if `intent_id` is provided) Delete all references to a specific entity. If `value_id` is provided, only references to that entity value are deleted."
          },
          "value_id": {
            "type": "string",
            "description": "(Optional) Delete all references to a specific entity value. If `text` is provided, only references to that entity value text are deleted. If not specified, delete all references to the entity."
          },
          "text": {
            "type": "string",
            "description": "(Optional) Delete all references to a specific entity value text. If not specified, delete all references to the entity value."
          },
          "intent_id": {
            "type": "string",
            "description": "(Optional if `entity_id` is provided) Delete all references of all phrases from a specific intent. If not specified, delete all references to the entity if `entity_id` is provided."
          }
        }
      },
      "DeleteEntityReferencesResponse": {
        "title": "DeleteEntityReferencesResponse",
        "properties": {
          "deleted_count": {
            "type": "integer",
            "description": "Number of deleted references.",
            "format": "uint32"
          }
        }
      },
      "DeleteEntityResponse": {
        "title": "DeleteEntityResponse",
        "properties": {}
      },
      "DeleteEntityValueResponse": {
        "title": "DeleteEntityValueResponse",
        "properties": {}
      },
      "DeleteIntentsRequest": {
        "title": "DeleteIntentsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "IDs of the intents to delete"
          }
        }
      },
      "DeleteIntentsResponse": {
        "title": "DeleteIntentsResponse",
        "properties": {
          "background_operation": {
            "$ref": "#/components/schemas/Operation"
          }
        }
      },
      "DeleteTagResponse": {
        "title": "DeleteTagResponse",
        "properties": {}
      },
      "DeleteTrainingPhraseRequest": {
        "title": "DeleteTrainingPhraseRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent_id": {
            "type": "string",
            "description": "ID of the intent in which the phrase is"
          },
          "phrase_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "IDs of the phrases to delete"
          },
          "override_protection": {
            "type": "boolean",
            "description": "Override protection on phrases"
          }
        }
      },
      "DeleteTrainingPhraseResponse": {
        "title": "DeleteTrainingPhraseResponse",
        "properties": {}
      },
      "DescribeTriggerResponse": {
        "title": "DescribeTriggerResponse",
        "properties": {
          "trigger_state": {
            "$ref": "#/components/schemas/TriggerState"
          }
        }
      },
      "Dialogflow": {
        "title": "Dialogflow",
        "properties": {
          "repeat_count": {
            "type": "integer",
            "description": "For Dialogflow CX, this maps to the `repeatCount` field of training phrase that was sourced. For Dialogflow ES, this maps to the `timesAddedCount` field of the training phrase that was sourced, or the`count` field in the usersays object that source via an ES Agent JSON Package.",
            "format": "int32"
          }
        }
      },
      "DialogflowCx": {
        "title": "DialogflowCx",
        "properties": {
          "flow_id": {
            "type": "string",
            "description": "If defined, indicates that the tag was created to correspond to a DialogFlow flow. This is used to properly re-assign intents to their corresponding flows based on tags."
          },
          "page_id": {
            "type": "string",
            "description": "If defined, indicates that the tag was created to correspond to a DialogFlow page. This is used to properly re-assign intents to their corresponding pages based on tags."
          },
          "transition_route_group_id": {
            "type": "string",
            "description": "If defined, indicates that the tag was created to correspond to a DialogFlow transition route group. This is used to properly re-assign intents to their corresponding transition route group based on tags."
          },
          "orphan": {
            "type": "boolean",
            "description": "If defined, indicates that the tag was created to signal that an intent is not attached to any flow, page, or transition route group."
          }
        }
      },
      "DialogflowEs": {
        "title": "DialogflowEs",
        "properties": {
          "priority": {
            "$ref": "#/components/schemas/Priority"
          },
          "top_level": {
            "$ref": "#/components/schemas/TopLevel"
          },
          "context": {
            "$ref": "#/components/schemas/Context"
          },
          "follow_up": {
            "$ref": "#/components/schemas/FollowUp"
          }
        }
      },
      "Empty": {
        "title": "Empty",
        "properties": {},
        "description": "A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance:     service Foo {       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);     }"
      },
      "Entity": {
        "title": "Entity",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier used for database storage"
          },
          "key": {
            "type": "string",
            "description": "Key by which we can refer to this entity in the utterance Ex (rasa): `I'd like to visit [New York City](city)` where `city` is the key"
          },
          "regex": {
            "$ref": "#/components/schemas/RegexKind"
          },
          "system": {
            "$ref": "#/components/schemas/SystemKind"
          },
          "values": {
            "$ref": "#/components/schemas/ValuesEntry"
          },
          "source": {
            "$ref": "#/components/schemas/EntitySource"
          },
          "settings": {
            "$ref": "#/components/schemas/EntitySettings"
          },
          "created_at": {
            "type": "string",
            "description": "Creation date of the entity",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "description": "(Optional) Update date of the entity",
            "format": "RFC3339"
          },
          "deleted_at": {
            "type": "string",
            "description": "(Optional) Deletion date of the entity",
            "format": "RFC3339"
          }
        }
      },
      "EntityMatch": {
        "title": "EntityMatch",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/EntityReference"
          },
          "score": {
            "type": "number",
            "description": "The confidence score for this match",
            "format": "float"
          },
          "span": {
            "$ref": "#/components/schemas/Span"
          },
          "extractor": {
            "type": "string",
            "description": "(Rasa specific) Name of the pipeline component that found this entity"
          }
        }
      },
      "EntityReference": {
        "title": "EntityReference",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Unique identifier of the entity for database storage."
          },
          "key": {
            "type": "string",
            "description": "Key by which we can refer to this entity in the utterance. Ex (rasa): `I'd like to visit [New York City](city)` where `city` is the key"
          },
          "invalid_entity": {
            "type": "boolean",
            "description": "Indicates that the reference points to an invalid entity."
          },
          "text": {
            "type": "string",
            "description": "Text used to reference the entity in the utterance Ex (rasa): `I'd like to visit [New York City](city)` where `New York City` is the text."
          },
          "value": {
            "type": "string",
            "description": "If the reference text isn't the main entity value, this value points to the right key value to use. For example, for a `city` entity, if a synonym was used, this value would contain the key value it refers to in the entity.    (rasa long): I went to [NYC]{\"entity\": \"city\", \"value\": \"New York City\"}                 where 'New York City' is the value    (rasa short): I went to [NYC](city:New York City)"
          },
          "value_id": {
            "type": "string",
            "description": "Unique identifier of the entity value for database storage."
          },
          "invalid_value": {
            "type": "boolean",
            "description": "Indicates that the reference points to an invalid entity value."
          },
          "role": {
            "type": "string",
            "description": "If entity has repeated usage in the utterance, assigns role for each usage Ex (rasa): I want to fly from [Berlin]{\"entity\": \"city\", \"role\": \"departure\"} to [San Francisco]{\"entity\": \"city\", \"role\": \"destination\"}."
          },
          "source": {
            "$ref": "#/components/schemas/ReferenceSource"
          },
          "implicit_value": {
            "type": "boolean",
            "description": "Reports whether the reference entity value is implicit or not."
          }
        },
        "description": "Some fields are replicated in: zia.ai.external_nlu.v1alpha1.EntityReference zia.ai.nlu.v1alpha1.EntityReference"
      },
      "EntityReferences": {
        "title": "EntityReferences",
        "properties": {
          "reference_count": {
            "type": "integer",
            "description": "Total number of phrases referencing this entity",
            "format": "uint32"
          },
          "values_references": {
            "$ref": "#/components/schemas/ValuesReferencesEntry"
          },
          "role_references": {
            "$ref": "#/components/schemas/RoleReferencesEntry"
          }
        }
      },
      "EntityReferencesEntry": {
        "title": "EntityReferencesEntry",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/EntityReferences"
          }
        }
      },
      "EntitySettings": {
        "title": "EntitySettings",
        "properties": {
          "allowed_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Intents that are allowed to be annotated with this entity. If empty, all intents are considered allowed."
          },
          "denied_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Intents that are not allowed to be annotated with this entity. If empty, no intents are considered denied."
          }
        }
      },
      "EntitySource": {
        "title": "EntitySource",
        "properties": {
          "source_id": {
            "type": "string",
            "description": "ID of the entity at its source if it has been imported"
          },
          "merged_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of unique identifiers of entity from HumanFirst or external integrations that got merged into this entity at some point and that can be reused to ease further merges. This list may not be exhaustive and could be truncated."
          },
          "dialogflow": {
            "$ref": "#/components/schemas/Dialogflow"
          },
          "rasa": {
            "$ref": "#/components/schemas/Rasa"
          },
          "humanfirst": {
            "$ref": "#/components/schemas/HumanFirst"
          }
        }
      },
      "EntityValue": {
        "title": "EntityValue",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier used for database storage."
          },
          "entity_id": {
            "type": "string",
            "description": "Unique identifier of the entity for database storage. There is no guarantee that this field will be filled in. Use the id on the entity instead."
          },
          "key_value": {
            "type": "string",
            "description": "Main value of the synonym (ex: New York City) of normal entities. For regex entities, this is the value of the regex."
          },
          "key_value_entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputEntity"
            },
            "description": "If supported by the NLU engine, entities referenced in `key_value`. Ex: DialogFlow composite entities are referenced here. If the `key_value_parts` field is provided on creation or update, this field is ignored and rebuilt from `key_value_parts`."
          },
          "key_value_parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputPart"
            },
            "description": "If supported by the NLU engine and that `key_value` contains entity references, this field contains the parts of the text and the entities. The parts are concatenated to form the final text. Parts are provided to ease entity annotations."
          },
          "language": {
            "type": "string",
            "description": "Value in which this entity synonym is."
          },
          "synonyms": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Synonyms of the entity value (ex: NYC, The Big Apple) Deprecated in favor of `complex_synonyms`. Synonyms that are created are converted to `complex_synonyms` on read."
          },
          "complex_synonyms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ComplexSynonym"
            },
            "description": "Synonyms of the entity value, with complex values. Ex: synonyms that contain entity references."
          },
          "source": {
            "$ref": "#/components/schemas/EntityValueSource"
          },
          "created_at": {
            "type": "string",
            "description": "Creation date of the entity value",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "description": "(Optional) Update date of the entity value",
            "format": "RFC3339"
          },
          "deleted_at": {
            "type": "string",
            "description": "(Optional) Deletion date of the entity value",
            "format": "RFC3339"
          },
          "implicit": {
            "type": "boolean",
            "description": "Signals that the entity value is not explicitly declared on an entity."
          },
          "position": {
            "type": "integer",
            "description": "The position occupied by the entity value under its parent entity.",
            "format": "uint32"
          }
        }
      },
      "EntityValueSource": {
        "title": "EntityValueSource",
        "properties": {
          "source_id": {
            "type": "string",
            "description": "ID of the entity value at its source if it has been imported (if applicable)"
          },
          "merged_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of unique identifiers of entity values from HumanFirst or external integrations that got merged into this entity values at some point and that can be reused to ease further merges. This list may not be exhaustive and could be truncated."
          },
          "rasa": {
            "$ref": "#/components/schemas/Rasa"
          }
        }
      },
      "Error": {
        "title": "Error",
        "properties": {
          "code": {
            "type": "integer",
            "format": "uint32"
          },
          "message": {
            "type": "string"
          }
        }
      },
      "ErrorDetails": {
        "title": "ErrorDetails",
        "properties": {
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Any"
            }
          }
        }
      },
      "Evaluation": {
        "title": "Evaluation",
        "properties": {
          "parameters": {
            "$ref": "#/components/schemas/EvaluationParameters"
          },
          "auto_evaluate": {
            "type": "boolean",
            "description": "Allow preset to be periodically evaluated automatically."
          }
        },
        "description": "Contains settings for running evaluations via `zia.ai.playbook.v1alpha1.RunEvaluation`. See `zia.ai.evaluation.v1alpha1.RunEvaluationRequest` for the matching fields that this connects to."
      },
      "EvaluationParameters": {
        "title": "EvaluationParameters",
        "properties": {
          "intent_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          },
          "k_fold": {
            "$ref": "#/components/schemas/KFold"
          },
          "test_set": {
            "$ref": "#/components/schemas/TestSet"
          },
          "nlu_id": {
            "type": "string",
            "description": "Optional unique identifier of the NLU engine to use in the workspace. If none specified, the workspace's default configured NLU engine will be used. See `zia.ai.pipeline.v1alpha1.NluSettings.id`"
          },
          "evaluation_preset_id": {
            "type": "string",
            "description": "If specified, the evaluation parameters will be overridden by the parameters of the given preset id, discarding any current values."
          },
          "auto": {
            "type": "boolean",
            "description": "If true, signals that the evaluation is an automatic run."
          },
          "include_system_and_regex_entities": {
            "type": "boolean",
            "description": "Include system and regex entities."
          }
        }
      },
      "EvaluationSettings": {
        "title": "EvaluationSettings",
        "properties": {
          "default_parameters": {
            "$ref": "#/components/schemas/EvaluationParameters"
          }
        }
      },
      "ExportConversationsFileRequest": {
        "title": "ExportConversationsFileRequest",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Unique identifier of the conversation source in which we want to export files from."
          },
          "conversation_set_id": {
            "type": "string",
            "description": "If specified and conversation_source_id is empty, the source will be retrieved from the conversation set."
          },
          "filenames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "If specified, only export the given filenames."
          }
        }
      },
      "ExportConversationsFileResponse": {
        "title": "ExportConversationsFileResponse",
        "properties": {
          "export_id": {
            "type": "string",
            "description": "A unique identifier used to retrive the export via the related http handler. This identifier is valid for 1 minute."
          },
          "export_url_path": {
            "type": "string",
            "description": "The http url path to access for downloading the export."
          }
        }
      },
      "ExportIntentsRequest": {
        "title": "ExportIntentsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "format": {
            "type": "integer",
            "description": "Format of the exported data. Values: 1 = CSV 2 = Rasa 1 Markdown 3 = Rasa 2 YAML 4 = Botpress 6 = Dialogflow ES 7 = Humanfirst JSON 8 = Cognigy JSON 9 = Dialogflow CX JSON",
            "format": "enum"
          },
          "format_options": {
            "$ref": "#/components/schemas/IntentsDataOptions"
          },
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "(Optional) Limit export to these given intents."
          }
        }
      },
      "ExportIntentsResponse": {
        "title": "ExportIntentsResponse",
        "properties": {
          "data": {
            "type": "string",
            "description": "Bytes of the exported file. The format is the one requested through the `format` field in request.",
            "format": "bytes"
          },
          "problems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationProblem"
            },
            "description": "List of problems that occurred while exporting intents. This list may not be exhaustive. If it's been limited, the `total_problems` indicate the total count."
          },
          "total_problems": {
            "type": "integer",
            "description": "Indicates total number of problems at import.",
            "format": "uint32"
          }
        }
      },
      "Field": {
        "title": "Field",
        "properties": {
          "name": {
            "type": "string"
          },
          "inherited": {
            "type": "boolean",
            "description": "Indicates that the field got inherited from a dependency. Ex: A field defined in data set schema can be inherited by the workspace schema."
          },
          "type": {
            "$ref": "#/components/schemas/Type"
          },
          "source": {
            "$ref": "#/components/schemas/FieldSource"
          },
          "indexation": {
            "$ref": "#/components/schemas/Indexation"
          }
        }
      },
      "FieldMask": {
        "title": "FieldMask",
        "properties": {
          "paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The set of field mask paths."
          }
        },
        "description": "`FieldMask` represents a set of symbolic field paths, for example:     paths: \"f.a\"     paths: \"f.b.d\" Here `f` represents a field in some root message, `a` and `b` fields in the message found in `f`, and `d` a field found in the message in `f.b`. Field masks are used to specify a subset of fields that should be returned by a get operation or modified by an update operation. Field masks also have a custom JSON encoding (see below). # Field Masks in Projections When used in the context of a projection, a response message or sub-message is filtered by the API to only contain those fields as specified in the mask. For example, if the mask in the previous example is applied to a response message as follows:     f {       a : 22       b {         d : 1         x : 2       }       y : 13     }     z: 8 The result will not contain specific values for fields x,y and z (their value will be set to the default, and omitted in proto text output):     f {       a : 22       b {         d : 1       }     } A repeated field is not allowed except at the last position of a paths string. If a FieldMask object is not present in a get operation, the operation applies to all fields (as if a FieldMask of all fields had been specified). Note that a field mask does not necessarily apply to the top-level response message. In case of a REST get operation, the field mask applies directly to the response, but in case of a REST list operation, the mask instead applies to each individual message in the returned resource list. In case of a REST custom method, other definitions may be used. Where the mask applies will be clearly documented together with its declaration in the API.  In any case, the effect on the returned resource/resources is required behavior for APIs. # Field Masks in Update Operations A field mask in update operations specifies which fields of the targeted resource are going to be updated. The API is required to only change the values of the fields as specified in the mask and leave the others untouched. If a resource is passed in to describe the updated values, the API ignores the values of all fields not covered by the mask. If a repeated field is specified for an update operation, new values will be appended to the existing repeated field in the target resource. Note that a repeated field is only allowed in the last position of a `paths` string. If a sub-message is specified in the last position of the field mask for an update operation, then new value will be merged into the existing sub-message in the target resource. For example, given the target message:     f {       b {         d: 1         x: 2       }       c: [1]     } And an update message:     f {       b {         d: 10       }       c: [2]     } then if the field mask is:  paths: [\"f.b\", \"f.c\"] then the result will be:     f {       b {         d: 10         x: 2       }       c: [1, 2]     } An implementation may provide options to override this default behavior for repeated and message fields. In order to reset a field's value to the default, the field must be in the mask and set to the default value in the provided resource. Hence, in order to reset all fields of a resource, provide a default instance of the resource and set all fields in the mask, or do not provide a mask as described below. If a field mask is not present on update, the operation applies to all fields (as if a field mask of all fields has been specified). Note that in the presence of schema evolution, this may mean that fields the client does not know and has therefore not filled into the request will be reset to their default. If this is unwanted behavior, a specific service may require a client to always specify a field mask, producing an error if not. As with get operations, the location of the resource which describes the updated values in the request message depends on the operation kind. In any case, the effect of the field mask is required to be honored by the API. ## Considerations for HTTP REST The HTTP kind of an update operation which uses a field mask must be set to PATCH instead of PUT in order to satisfy HTTP semantics (PUT must only be used for full updates). # JSON Encoding of Field Masks In JSON, a field mask is encoded as a single string where paths are separated by a comma. Fields name in each path are converted to/from lower-camel naming conventions. As an example, consider the following message declarations:     message Profile {       User user = 1;       Photo photo = 2;     }     message User {       string display_name = 1;       string address = 2;     } In proto a field mask for `Profile` may look as such:     mask {       paths: \"user.display_name\"       paths: \"photo\"     } In JSON, the same mask is represented as below:     {       mask: \"user.displayName,photo\"     } # Field Masks and Oneof Fields Field masks treat fields in oneofs just as regular fields. Consider the following message:     message SampleMessage {       oneof test_oneof {         string name = 4;         SubMessage sub_message = 9;       }     } The field mask can be:     mask {       paths: \"name\"     } Or:     mask {       paths: \"sub_message\"     } Note that oneof type names (\"test_oneof\" in this case) cannot be used in paths. ## Field Mask Verification The implementation of any API method which has a FieldMask type field in the request should verify the included field paths, and return an `INVALID_ARGUMENT` error if any path is unmappable."
      },
      "FieldSource": {
        "title": "FieldSource",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/MetadataSource"
          }
        }
      },
      "File": {
        "title": "File",
        "properties": {
          "name": {
            "type": "string",
            "description": "File name"
          },
          "format": {
            "type": "integer",
            "description": "Format of the conversations in file",
            "format": "enum"
          },
          "upload_time": {
            "type": "string",
            "description": "Indicates the time at which the file got uploaded",
            "format": "RFC3339"
          },
          "from_last_upload": {
            "type": "boolean",
            "description": "Indicates that the file was part of the last upload"
          }
        }
      },
      "Float": {
        "title": "Float",
        "properties": {
          "not_stored": {
            "type": "boolean"
          },
          "quantization_multiplier": {
            "type": "number",
            "description": "Quantization multiplier, used to quantize the value of the field into a smaller range. For each value, we multiply it by the quantization multiplier and store the result without decimals. By default, the quantization multiplier is 100, meaning that stored values will range from 0 to 100.",
            "format": "float"
          }
        }
      },
      "Fragment": {
        "title": "Fragment",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FragmentItem"
            },
            "description": "Array of inputs/placeholders found in this fragment"
          },
          "location": {
            "$ref": "#/components/schemas/PhraseLocation"
          }
        }
      },
      "FragmentItem": {
        "title": "FragmentItem",
        "properties": {
          "input": {
            "$ref": "#/components/schemas/Input"
          },
          "placeholder": {
            "$ref": "#/components/schemas/Placeholder"
          }
        }
      },
      "GenerationRunStatistics": {
        "title": "GenerationRunStatistics",
        "properties": {
          "input_count": {
            "type": "integer",
            "description": "The number of inputs used in the nlg generation run.",
            "format": "uint32"
          },
          "output_count": {
            "type": "integer",
            "description": "The number of outputs generated in the nlg generation run. This includes outputs generated by the post-processing (ex: spliting by new lines will generate multiple outputs from a single output).",
            "format": "uint32"
          },
          "failure_count": {
            "type": "integer",
            "description": "The number of failures encountered in the nlg generation run.",
            "format": "uint32"
          },
          "cached_count": {
            "type": "integer",
            "description": "The number of outputs that were retrieved from the cache and not freshly generated by an LLM.",
            "format": "uint32"
          }
        }
      },
      "GetEntityResponse": {
        "title": "GetEntityResponse",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/Entity"
          }
        }
      },
      "GetEntitySettingsResponse": {
        "title": "GetEntitySettingsResponse",
        "properties": {
          "allowed_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The explicit list of intent ids that are permitted for this entity to be attached to."
          },
          "denied_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The explicit list of intent ids that are not permitted for this entity to be attached to."
          }
        }
      },
      "GetIntentsCoverageResponse": {
        "title": "GetIntentsCoverageResponse",
        "properties": {
          "report": {
            "$ref": "#/components/schemas/IntentsCoverage"
          }
        }
      },
      "GetIntentsStatsResponse": {
        "title": "GetIntentsStatsResponse",
        "properties": {
          "intents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntentStatistics"
            }
          }
        }
      },
      "GetOperationResponse": {
        "title": "GetOperationResponse",
        "properties": {
          "operation": {
            "$ref": "#/components/schemas/Operation"
          }
        }
      },
      "GetTrainingPhraseResponse": {
        "title": "GetTrainingPhraseResponse",
        "properties": {
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          }
        }
      },
      "HierIntentMatch": {
        "title": "HierIntentMatch",
        "properties": {
          "id": {
            "type": "string",
            "description": "The intent id that was matched."
          },
          "name": {
            "type": "string",
            "description": "The name of the intent when the model was trained."
          },
          "score": {
            "type": "number",
            "description": "The recursive sum of the scores of all the sub-intents.",
            "format": "float"
          },
          "own_score": {
            "type": "number",
            "description": "The probability of this intent, if its children were disregarded.",
            "format": "float"
          },
          "children_entropy": {
            "type": "number",
            "description": "The entropy of the intent's direct children.",
            "format": "float"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HierIntentMatch"
            },
            "description": "The match probabilities for this intent's direct children"
          }
        }
      },
      "HttpBody": {
        "title": "HttpBody",
        "properties": {
          "content_type": {
            "type": "string",
            "description": "The HTTP Content-Type header value specifying the content type of the body."
          },
          "data": {
            "type": "string",
            "description": "The HTTP request/response body as raw binary.",
            "format": "bytes"
          },
          "extensions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Any"
            },
            "description": "Application specific response metadata. Must be set in the first response for streaming APIs."
          }
        },
        "description": "Message that represents an arbitrary HTTP body. It should only be used for payload formats that can't be represented as JSON, such as raw binary or an HTML page. This message can be used both in streaming and non-streaming API methods in the request as well as the response. It can be used as a top-level request field, which is convenient if one wants to extract parameters from either the URL or HTTP template into the request fields and also want access to the raw HTTP body. Example:     message GetResourceRequest {       // A unique request id.       string request_id = 1;       // The raw HTTP body is bound to this field.       google.api.HttpBody http_body = 2;     }     service ResourceService {       rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);       rpc UpdateResource(google.api.HttpBody) returns       (google.protobuf.Empty);     } Example with streaming methods:     service CaldavService {       rpc GetCalendar(stream google.api.HttpBody)         returns (stream google.api.HttpBody);       rpc UpdateCalendar(stream google.api.HttpBody)         returns (stream google.api.HttpBody);     } Use of this type only changes how the request and response bodies are handled, all other features will continue to work unchanged."
      },
      "HumanFirst": {
        "title": "HumanFirst",
        "properties": {
          "match_mode": {
            "type": "integer",
            "description": "Controls how the entity gets matched.",
            "format": "enum"
          }
        }
      },
      "ImportConversationsFileRequest": {
        "title": "ImportConversationsFileRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Unique identifier of the conversation source in which we want to import the file."
          },
          "conversation_set_id": {
            "type": "string",
            "description": "If specified and conversation_source_id is empty, the source will be retrieved from the conversation set."
          },
          "validate_only": {
            "type": "boolean",
            "description": "If true, return after validating the file and skip the import."
          },
          "filename": {
            "type": "string",
            "description": "Name of the file that is being uploaded. Note: this name may be mangled by the backend if it contains invalid characters. The mangled name will be returned in the response."
          },
          "format": {
            "type": "integer",
            "description": "File format.",
            "format": "enum"
          },
          "data": {
            "type": "string",
            "description": "File content.",
            "format": "bytes"
          },
          "column_mapper_options": {
            "$ref": "#/components/schemas/ColumnMapperOptions"
          },
          "soft_fail": {
            "type": "boolean",
            "description": "Returns fatal problems via the `problems` field instead of gRPC errors. Temporary flag until front-end properly handles soft failures instead of gRPC error."
          },
          "no_trigger": {
            "type": "boolean",
            "description": "Don't trigger the pipeline after importing the file. This will not process the new file, but it will be processed on the next trigger."
          },
          "extra_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "If specified, add these tags to all imported conversation inputs."
          }
        }
      },
      "ImportConversationsFileResponse": {
        "title": "ImportConversationsFileResponse",
        "properties": {
          "filename": {
            "type": "string",
            "description": "File name as saved in the user upload location as mangled if invalid characters were present in it."
          },
          "problems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationProblem"
            },
            "description": "List of problems that occurred while validating the file format. This list may not be exhaustive. If it's been limited, the `total_problems` indicate the total count."
          },
          "total_problems": {
            "type": "integer",
            "description": "Indicates total number of problems at import.",
            "format": "uint32"
          },
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline trigger that was created when importing the file. This may be empty if the `no_trigger` field was set to true."
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Id of the conversation source. Useful if a conversation source had to be created."
          }
        }
      },
      "ImportDataFromIntegrationRequest": {
        "title": "ImportDataFromIntegrationRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "integration_id": {
            "type": "string",
            "description": "Id of the integration."
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Unique identifier of the conversation source in which we want to import the file. The source must be of a type represented by an integration capable of importing data."
          },
          "params": {
            "$ref": "#/components/schemas/IntegrationDataImportParams"
          }
        }
      },
      "ImportDataFromIntegrationResponse": {
        "title": "ImportDataFromIntegrationResponse",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline trigger that was created when importing the data."
          },
          "conversation_source_id": {
            "type": "string",
            "description": "Id of the conversation source. Useful if a conversation source had to be created."
          }
        }
      },
      "ImportIntentsRequest": {
        "title": "ImportIntentsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "format": {
            "type": "integer",
            "description": "Format of the imported file. Values: 1 = CSV 2 = Rasa 1 Markdown 3 = Rasa 2 YAML 4 = Botpress 6 = Dialogflow ES 7 = Humanfirst JSON 8 = Cognigy JSON 9 = Dialogflow CX JSON",
            "format": "enum"
          },
          "format_options": {
            "$ref": "#/components/schemas/IntentsDataOptions"
          },
          "import_options": {
            "$ref": "#/components/schemas/ImportOptions"
          },
          "data": {
            "type": "string",
            "description": "Bytes of the file to import. The format is the one requested through the `format` field in request.",
            "format": "bytes"
          },
          "clear_workspace": {
            "type": "boolean",
            "description": "Clears workspace intents, entities & tags before importing. Deprecated: use `import_options`"
          },
          "clear_intents": {
            "type": "boolean",
            "description": "Clears workspace intents before importing. Deprecated: use `import_options`"
          },
          "clear_entities": {
            "type": "boolean",
            "description": "Clears workspace entities before importing. Deprecated: use `import_options`"
          },
          "clear_tags": {
            "type": "boolean",
            "description": "Clears workspace tags before importing. Note: should not be used in combination with `extra_intent_tags` or `extra_phrase_tags` since       we will clear potentially referenced tags. Deprecated: use `import_options`"
          },
          "merge_intents": {
            "type": "boolean",
            "description": "Tries to merge intents into existing ones if they can be found in the workspace. Deprecated: use `import_options`"
          },
          "merge_entities": {
            "type": "boolean",
            "description": "Tries to merge entities into existing ones if they can be found in the workspace. Deprecated: use `import_options`"
          },
          "merge_tags": {
            "type": "boolean",
            "description": "Tries to merge tags into existing ones if they can be found in the workspace. Deprecated: use `import_options`"
          },
          "soft_fail": {
            "type": "boolean",
            "description": "Returns fatal problems via the `problems` field instead of gRPC errors. Temporary flag until front-end properly handles soft failures instead of gRPC error."
          },
          "extra_intent_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Add extra tags to imported intents. Deprecated: use `import_options`"
          },
          "extra_phrase_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Add extra tags to imported phrases. Deprecated: use `import_options`"
          }
        }
      },
      "ImportIntentsResponse": {
        "title": "ImportIntentsResponse",
        "properties": {
          "imported_intent_count": {
            "type": "integer",
            "description": "Number of intents that were imported.",
            "format": "uint32"
          },
          "imported_training_phrase_count": {
            "type": "integer",
            "description": "Number of training phrases that were imported.",
            "format": "uint32"
          },
          "problems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationProblem"
            },
            "description": "List of problems that occurred while validating the file format. This list may not be exhaustive. If it's been limited, the `total_problems` indicate the total count."
          },
          "total_problems": {
            "type": "integer",
            "description": "Indicates total number of problems at import.",
            "format": "uint32"
          },
          "background_operation": {
            "$ref": "#/components/schemas/Operation"
          }
        }
      },
      "ImportOptions": {
        "title": "ImportOptions",
        "properties": {
          "clear_intents": {
            "type": "boolean",
            "description": "Clears workspace intents before importing."
          },
          "clear_entities": {
            "type": "boolean",
            "description": "Clears workspace entities before importing."
          },
          "clear_tags": {
            "type": "boolean",
            "description": "Clears workspace tags before importing. Note: should not be used in combination with `extra_intent_tags` or `extra_phrase_tags` since       we will clear potentially referenced tags."
          },
          "merge_intents": {
            "type": "boolean",
            "description": "Tries to merge intents into existing ones if they can be found in the workspace."
          },
          "merge_entities": {
            "type": "boolean",
            "description": "Tries to merge entities into existing ones if they can be found in the workspace."
          },
          "merge_tags": {
            "type": "boolean",
            "description": "Tries to merge tags into existing ones if they can be found in the workspace."
          },
          "extra_intent_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Add extra tags to imported intents."
          },
          "extra_phrase_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Add extra tags to imported phrases."
          },
          "override_metadata": {
            "type": "boolean",
            "description": "Overrides the description, color, and metadata of the workspace with the values of the imported file if they are supported in the received format. Supported formats: `INTENTS_FORMAT_HF_JSON`"
          },
          "override_name": {
            "type": "boolean",
            "description": "Overrides the name of the workspace with the value of the imported file if they are supported in the received format. Supported formats: `INTENTS_FORMAT_HF_JSON`"
          }
        }
      },
      "Indexation": {
        "title": "Indexation",
        "properties": {
          "string": {
            "$ref": "#/components/schemas/String"
          },
          "int": {
            "$ref": "#/components/schemas/Int"
          },
          "float": {
            "$ref": "#/components/schemas/Float"
          },
          "bool": {
            "$ref": "#/components/schemas/Bool"
          },
          "timestamp": {
            "$ref": "#/components/schemas/Timestamp"
          }
        }
      },
      "Input": {
        "title": "Input",
        "properties": {
          "text": {
            "type": "string",
            "description": "The verbatim input text"
          },
          "source": {
            "type": "integer",
            "description": "Whether the input comes from an expert or user",
            "format": "enum"
          },
          "input_id": {
            "type": "string",
            "description": "The normalized input / example id from the pipeline"
          },
          "created_at": {
            "type": "string",
            "description": "The absolute timestamp when the input was uttered",
            "format": "RFC3339"
          }
        }
      },
      "InputEntity": {
        "title": "InputEntity",
        "properties": {
          "reference": {
            "$ref": "#/components/schemas/EntityReference"
          },
          "span": {
            "$ref": "#/components/schemas/SpanIndex"
          }
        },
        "description": "An entity reference, with the additional information on where it has been found in an utterance."
      },
      "InputPart": {
        "title": "InputPart",
        "properties": {
          "text": {
            "$ref": "#/components/schemas/Text"
          },
          "entity": {
            "$ref": "#/components/schemas/EntityReference"
          }
        }
      },
      "InsightsApply": {
        "title": "InsightsApply",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "insight_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Int": {
        "title": "Int",
        "properties": {
          "not_stored": {
            "type": "boolean"
          }
        }
      },
      "IntegrationDataImport": {
        "title": "IntegrationDataImport",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string"
          }
        }
      },
      "IntegrationDataImportParams": {
        "title": "IntegrationDataImportParams",
        "properties": {
          "recurring_import_strategy": {
            "$ref": "#/components/schemas/ScheduleStrategy"
          },
          "recurring_import_initial_pivot_date": {
            "type": "string",
            "description": "If there is recurring import strategy, then this can be used as the pivot date for the first import to avoid importing everything. This is currently only supported by the following integrations:  - BigQuery  - Infobip",
            "format": "RFC3339"
          },
          "bigquery": {
            "$ref": "#/components/schemas/IntegrationDataImportParamsBigQuery"
          },
          "infobip": {
            "$ref": "#/components/schemas/IntegrationDataImportParamsInfobip"
          },
          "sql": {
            "$ref": "#/components/schemas/IntegrationDataImportParamsSql"
          }
        }
      },
      "IntegrationDataImportParamsBigQuery": {
        "title": "IntegrationDataImportParamsBigQuery",
        "properties": {
          "sql": {
            "type": "string",
            "description": "SQL query to send to the integration. Required if the integration is SQL-based. Must be null if not. If a recurring import strategy is set, the query must be contain a parameter named `@pivot_date`."
          },
          "column_mapper_options": {
            "$ref": "#/components/schemas/ColumnMapperOptions"
          }
        }
      },
      "IntegrationDataImportParamsInfobip": {
        "title": "IntegrationDataImportParamsInfobip",
        "properties": {
          "created_after": {
            "type": "string",
            "format": "RFC3339"
          },
          "created_before": {
            "type": "string",
            "format": "RFC3339"
          },
          "updated_after": {
            "type": "string",
            "format": "RFC3339"
          },
          "updated_before": {
            "type": "string",
            "format": "RFC3339"
          },
          "closed_after": {
            "type": "string",
            "format": "RFC3339"
          },
          "closed_before": {
            "type": "string",
            "format": "RFC3339"
          }
        }
      },
      "IntegrationDataImportParamsSql": {
        "title": "IntegrationDataImportParamsSql",
        "properties": {
          "sql": {
            "type": "string",
            "description": "SQL query to send to the integration. Required if the integration is SQL-based. Must be null if not."
          },
          "column_mapper_options": {
            "$ref": "#/components/schemas/ColumnMapperOptions"
          }
        }
      },
      "IntegrationImport": {
        "title": "IntegrationImport",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "integration_id": {
            "type": "string"
          },
          "integration_workspace_id": {
            "type": "string"
          },
          "integration_location": {
            "$ref": "#/components/schemas/Any"
          },
          "intent_options": {
            "$ref": "#/components/schemas/Any"
          },
          "import_options": {
            "$ref": "#/components/schemas/Any"
          }
        }
      },
      "Intent": {
        "title": "Intent",
        "properties": {
          "id": {
            "type": "string",
            "description": "UUID"
          },
          "name": {
            "type": "string",
            "description": "User-given name"
          },
          "type": {
            "type": "integer",
            "description": "Expert/User/Meta",
            "format": "enum"
          },
          "parent_id": {
            "type": "string",
            "description": "The intent's parent intent, within the same context"
          },
          "template_intent": {
            "$ref": "#/components/schemas/TemplateIntentInfo"
          },
          "inbound_contexts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Context"
            },
            "description": "Contexts which have to be active in order for this intent to match"
          },
          "outbound_contexts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Context"
            },
            "description": "Contexts to activate if this intent is matched"
          },
          "training_phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhrase"
            },
            "description": "Positive training phrases of the intent"
          },
          "negative_training_phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhrase"
            },
            "description": "Negative training phrases of the intent"
          },
          "training_phrase_list_id": {
            "type": "string",
            "description": "If the intent is from database, list identifier of training phrases"
          },
          "negative_training_phrase_list_id": {
            "type": "string",
            "description": "If the intent is from database, list identifier of negative training phrases"
          },
          "hidden_from_agents": {
            "type": "boolean",
            "description": "If true, the intent will not be visible to agents from the extension (defaults to false)"
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Tags of the intent."
          },
          "color": {
            "type": "string"
          },
          "hidden_from_follow_up_suggestions": {
            "type": "boolean",
            "description": "If true, this intent or its children won't be available within Answer's follow-up suggestions"
          },
          "follow_up_after_turn_count": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "follow_up_allow_repeat_after_turn_count": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "follow_up_implies_parent": {
            "type": "boolean"
          },
          "hidden_from_automate_matches": {
            "type": "boolean",
            "description": "If true, it will be considered by the classifier, but will never be returned as a match to a client"
          },
          "generic": {
            "type": "boolean",
            "description": "Generic intents are only used for its hierarchy, and are not expected to hold any responses"
          },
          "source": {
            "$ref": "#/components/schemas/IntentSourceInfo"
          },
          "out_of_scope": {
            "type": "boolean",
            "description": "If true, this intent will be used as a negative class when classifying if examples are in scope or not"
          },
          "metadata": {
            "$ref": "#/components/schemas/IntentMetadata"
          },
          "created_at": {
            "type": "string",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "format": "RFC3339"
          },
          "deleted_at": {
            "type": "string",
            "format": "RFC3339"
          }
        },
        "description": "Intents define a component that match on some external input or condition. It's purpose is to activate it's outbound contexts whenever the condition is met"
      },
      "IntentCoverage": {
        "title": "IntentCoverage",
        "properties": {
          "intent_id": {
            "type": "string"
          },
          "model_id": {
            "type": "string",
            "description": "unique identifier of the model from which the intent was inferred. may be empty if the default model doesn't have an unique NLU engine identifier."
          },
          "conversation_set_id": {
            "type": "string",
            "description": "unique identifier of the conversation set for which the coverage is computed. may be empty if the coverage is computed for all conv sets."
          },
          "unique_utterance_count": {
            "type": "integer",
            "description": "total count of unique utterances matching the intent",
            "format": "uint64"
          },
          "utterance_count": {
            "type": "integer",
            "description": "total count of utterances matching the intent",
            "format": "uint64"
          },
          "unique_utterance_hier_count": {
            "type": "integer",
            "description": "total count of unique utterances matching the intent or its children",
            "format": "uint64"
          },
          "utterance_hier_count": {
            "type": "integer",
            "description": "total count of utterances matching the intent or its children",
            "format": "uint64"
          },
          "unique_utterance_score_histogram": {
            "$ref": "#/components/schemas/UniqueUtteranceScoreHistogramEntry"
          },
          "utterance_score_histogram": {
            "$ref": "#/components/schemas/UtteranceScoreHistogramEntry"
          },
          "unique_utterance_hier_score_histogram": {
            "$ref": "#/components/schemas/UniqueUtteranceHierScoreHistogramEntry"
          },
          "utterance_hier_score_histogram": {
            "$ref": "#/components/schemas/UtteranceHierScoreHistogramEntry"
          }
        }
      },
      "IntentMatch": {
        "title": "IntentMatch",
        "properties": {
          "id": {
            "type": "string",
            "description": "The intent id that was matched."
          },
          "name": {
            "type": "string",
            "description": "The name of the intent when the model was trained."
          },
          "hierarchy_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Intent IDs of the lineage of the matched intent. The first ID is the root parent intent, the last is the matched intent."
          },
          "hierarchy_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Intent names of the lineage of the matched intent. The first name is the root parent intent, the last is the matched intent."
          },
          "score": {
            "type": "number",
            "description": "The probability of this being the right matched, as determined by the underlying model.",
            "format": "float"
          }
        }
      },
      "IntentMetadata": {
        "title": "IntentMetadata",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/MetadataEntry"
          },
          "description": {
            "type": "string",
            "description": "Description of the intent."
          }
        }
      },
      "IntentSourceInfo": {
        "title": "IntentSourceInfo",
        "properties": {
          "source_id": {
            "type": "string",
            "description": "ID of the intent at its source."
          },
          "merged_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of unique identifiers of intents from HumanFirst or external integrations that got merged into this intent at some point and that can be reused to ease further merges. This list may not be exhaustive and could be truncated."
          },
          "botpress": {
            "$ref": "#/components/schemas/Botpress"
          },
          "rasa": {
            "$ref": "#/components/schemas/Rasa"
          },
          "dialogflow": {
            "$ref": "#/components/schemas/Dialogflow"
          },
          "cognigy": {
            "$ref": "#/components/schemas/Cognigy"
          }
        }
      },
      "IntentStatistics": {
        "title": "IntentStatistics",
        "properties": {
          "intent_id": {
            "type": "string"
          },
          "intent_name": {
            "type": "string"
          },
          "training_phrase_count": {
            "type": "integer",
            "format": "uint32"
          },
          "negative_training_phrase_count": {
            "type": "integer",
            "format": "uint32"
          },
          "entity_references": {
            "$ref": "#/components/schemas/EntityReferencesEntry"
          },
          "total_entity_reference_count": {
            "type": "integer",
            "description": "Total number of entity references across all phrases",
            "format": "uint32"
          }
        }
      },
      "IntentTrainingPhrase": {
        "title": "IntentTrainingPhrase",
        "properties": {
          "training_phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          },
          "intent_id": {
            "type": "string"
          }
        }
      },
      "IntentsCopy": {
        "title": "IntentsCopy",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "source_namespace": {
            "type": "string"
          },
          "source_playbook_id": {
            "type": "string"
          },
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "exclude_training_phrases": {
            "type": "boolean"
          },
          "copy_entities": {
            "type": "boolean"
          },
          "phrase_tag_predicate": {
            "$ref": "#/components/schemas/Any"
          }
        }
      },
      "IntentsCoverage": {
        "title": "IntentsCoverage",
        "properties": {
          "intents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntentCoverage"
            }
          },
          "unique_utterance_count": {
            "type": "integer",
            "description": "total unique utterance count",
            "format": "uint64"
          },
          "utterance_count": {
            "type": "integer",
            "description": "total utterance count",
            "format": "uint64"
          },
          "utterance_score_histogram": {
            "$ref": "#/components/schemas/UtteranceScoreHistogramEntry"
          },
          "unique_utterance_score_histogram": {
            "$ref": "#/components/schemas/UniqueUtteranceScoreHistogramEntry"
          }
        }
      },
      "IntentsDataOptions": {
        "title": "IntentsDataOptions",
        "properties": {
          "hierarchical_intent_name_disabled": {
            "type": "boolean",
            "description": "Disables intents hierarchy encoding via the intent names. Ex: 'Parent / Sub-parent / Intent'"
          },
          "hierarchical_delimiter": {
            "type": "string",
            "description": "Overrides the default delimiter used for intent hierarchy. Default is '--' for Botpress and Dialogflow, '+' for Rasa, '/' for CSV"
          },
          "zip_encoding": {
            "type": "boolean",
            "description": "Indicates that the intents are zipped and may be splits in different files."
          },
          "gzip_encoding": {
            "type": "boolean",
            "description": "Indicates that the intent file is gzipped."
          },
          "include_negative_phrases": {
            "type": "boolean",
            "description": "Export negative phrases as well."
          },
          "intent_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          },
          "phrase_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          },
          "skip_empty_intents": {
            "type": "boolean",
            "description": "Skip all intents that do not contain phrases."
          }
        }
      },
      "IntentsExport": {
        "title": "IntentsExport",
        "properties": {
          "format": {
            "type": "integer",
            "description": "Format of the exported data.",
            "format": "enum"
          },
          "format_options": {
            "$ref": "#/components/schemas/IntentsDataOptions"
          },
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "(Optional) Limit export to these given intents."
          }
        },
        "description": "Contains settings for exporting intents via `zia.ai.playbook.data.v1alpha1.ExportIntents`. See `zia.ai.playbook.data.v1alpha1.ExportIntentsRequest` for the matching fields that this connects to."
      },
      "IntentsImport": {
        "title": "IntentsImport",
        "properties": {
          "format": {
            "type": "integer",
            "description": "Format of the imported file.",
            "format": "enum"
          },
          "format_options": {
            "$ref": "#/components/schemas/IntentsDataOptions"
          },
          "import_options": {
            "$ref": "#/components/schemas/ImportOptions"
          }
        },
        "description": "Contains settings for importing intents via `zia.ai.playbook.data.v1alpha1.ImportIntents`. See `zia.ai.evaluation.params.v1alpha1.ImportIntentsRequest` for the matching fields that this connects to."
      },
      "Item": {
        "title": "Item",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The length of the list will equal the length of the field_names field."
          }
        }
      },
      "JobTriggerData": {
        "title": "JobTriggerData",
        "properties": {
          "proto": {
            "$ref": "#/components/schemas/Any"
          },
          "raw": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "JobTriggerMetadata": {
        "title": "JobTriggerMetadata",
        "properties": {
          "pipeline_transform": {
            "$ref": "#/components/schemas/PipelineTransform"
          },
          "model_training": {
            "$ref": "#/components/schemas/ModelTraining"
          },
          "model_evaluation": {
            "$ref": "#/components/schemas/ModelEvaluation"
          },
          "playbook_revision": {
            "$ref": "#/components/schemas/PlaybookRevision"
          },
          "conversation_sets_link": {
            "$ref": "#/components/schemas/ConversationSetsLink"
          },
          "conversation_sets_unlink": {
            "$ref": "#/components/schemas/ConversationSetsUnlink"
          },
          "conversations_file_import": {
            "$ref": "#/components/schemas/ConversationsFileImport"
          },
          "thread_file_upload": {
            "$ref": "#/components/schemas/ThreadFileUpload"
          },
          "thread_file_deletion": {
            "$ref": "#/components/schemas/ThreadFileDeletion"
          },
          "conversations_file_delete": {
            "$ref": "#/components/schemas/ConversationsFileDelete"
          },
          "integration_data_import": {
            "$ref": "#/components/schemas/IntegrationDataImport"
          },
          "insights_apply": {
            "$ref": "#/components/schemas/InsightsApply"
          },
          "intents_copy": {
            "$ref": "#/components/schemas/IntentsCopy"
          },
          "integration_import": {
            "$ref": "#/components/schemas/IntegrationImport"
          },
          "playbook_create": {
            "$ref": "#/components/schemas/PlaybookCreate"
          },
          "playbook_clone": {
            "$ref": "#/components/schemas/PlaybookClone"
          },
          "intents_import": {
            "$ref": "#/components/schemas/IntentsImport"
          },
          "batch_actions": {
            "$ref": "#/components/schemas/BatchActions"
          },
          "manual_data_import": {
            "$ref": "#/components/schemas/ManualDataImport"
          },
          "schema_change": {
            "$ref": "#/components/schemas/SchemaChange"
          }
        }
      },
      "KFold": {
        "title": "KFold",
        "properties": {
          "num_folds": {
            "type": "integer",
            "description": "Number of folds",
            "format": "uint32"
          },
          "phrase_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          }
        }
      },
      "LinkConversationSetsRequest": {
        "title": "LinkConversationSetsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation sets and workspace are."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "conversation_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Unique identifiers of the conversation sets to link. Deprecated: Use conversation_sets instead. If conversation_set_ids is specified, they will be converted to conversation_sets with the given namespace."
          },
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScopedReference"
            },
            "description": "The conversation sets to link."
          }
        }
      },
      "LinkConversationSetsResponse": {
        "title": "LinkConversationSetsResponse",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline trigger that was created when linking the conversation sets. If there are no resulting changes to the list of linked conversation sets, this will be empty."
          }
        }
      },
      "ListConversationSetsResponse": {
        "title": "ListConversationSetsResponse",
        "properties": {
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversationSet"
            }
          }
        }
      },
      "ListConversationSourcesResponse": {
        "title": "ListConversationSourcesResponse",
        "properties": {
          "conversation_sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversationSource"
            }
          }
        }
      },
      "ListConversationsFileResponse": {
        "title": "ListConversationsFileResponse",
        "properties": {
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/File"
            },
            "description": "Files"
          }
        }
      },
      "ListEntitiesResponse": {
        "title": "ListEntitiesResponse",
        "properties": {
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Entity"
            }
          }
        }
      },
      "ListEntityTrainingPhrasesResponse": {
        "title": "ListEntityTrainingPhrasesResponse",
        "properties": {
          "phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntentTrainingPhrase"
            }
          },
          "total_count": {
            "type": "integer",
            "description": "Number of phrases in total",
            "format": "uint32"
          },
          "next_page_token": {
            "type": "string",
            "description": "Token of the next page of phrases",
            "format": "bytes"
          }
        }
      },
      "ListEntityValuesResponse": {
        "title": "ListEntityValuesResponse",
        "properties": {
          "entity_values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityValue"
            }
          }
        }
      },
      "ListIntentsResponse": {
        "title": "ListIntentsResponse",
        "properties": {
          "intents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Intent"
            }
          }
        }
      },
      "ListPlaybookNlgGenerationRunsResponse": {
        "title": "ListPlaybookNlgGenerationRunsResponse",
        "properties": {
          "runs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Run"
            },
            "description": "Listed nlg generation runs, sorted by id in descending order."
          }
        }
      },
      "ListPlaybookNluEnginesResponse": {
        "title": "ListPlaybookNluEnginesResponse",
        "properties": {
          "nlu_engines": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NluSettings"
            },
            "description": "Listed nlu engines."
          }
        }
      },
      "ListPlaybookPipelinesResponse": {
        "title": "ListPlaybookPipelinesResponse",
        "properties": {
          "pipelines": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Pipeline"
            },
            "description": "Listed pipelines."
          }
        }
      },
      "ListPlaybookPresetsResponse": {
        "title": "ListPlaybookPresetsResponse",
        "properties": {
          "presets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Preset"
            },
            "description": "Listed presets."
          }
        }
      },
      "ListPlaybooksResponse": {
        "title": "ListPlaybooksResponse",
        "properties": {
          "playbooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Playbook"
            },
            "description": "Listed workspaces"
          }
        }
      },
      "ListSystemEntitiesResponse": {
        "title": "ListSystemEntitiesResponse",
        "properties": {
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SystemEntity"
            }
          }
        }
      },
      "ListTagsResponse": {
        "title": "ListTagsResponse",
        "properties": {
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Tag"
            }
          }
        }
      },
      "ListTrainingPhraseMetadataKeysResponse": {
        "title": "ListTrainingPhraseMetadataKeysResponse",
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhraseMetadataKey"
            }
          }
        }
      },
      "ListTrainingPhrasesResponse": {
        "title": "ListTrainingPhrasesResponse",
        "properties": {
          "phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhrase"
            }
          },
          "total_count": {
            "type": "integer",
            "description": "Number of phrases in total",
            "format": "uint32"
          },
          "next_page_token": {
            "type": "string",
            "description": "Token of the next page of phrases",
            "format": "bytes"
          }
        }
      },
      "ListTriggersResponse": {
        "title": "ListTriggersResponse",
        "properties": {
          "trigger_states": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerState"
            },
            "description": "The trigger states for the object."
          }
        }
      },
      "ManualDataImport": {
        "title": "ManualDataImport",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "manual_data_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Mapper": {
        "title": "Mapper",
        "properties": {
          "name": {
            "type": "string"
          },
          "kind": {
            "type": "integer",
            "format": "enum"
          }
        }
      },
      "MetadataEntry": {
        "title": "MetadataEntry",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "MetadataSource": {
        "title": "MetadataSource",
        "properties": {
          "key": {
            "type": "string",
            "description": "Key from which the field is extracted from the metadata."
          },
          "parse_string": {
            "type": "boolean",
            "description": "Expect the field to be a string and try to parse it as a string."
          },
          "parse_format": {
            "type": "string",
            "description": "For type like timestamp, the format in which the timestamp is stored in the metadata. This follows Golang time package format: https://golang.org/pkg/time/#pkg-constants Ex: 2006-01-02 15:04:05"
          }
        }
      },
      "ModelEvaluation": {
        "title": "ModelEvaluation",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "evaluation_parameters": {
            "$ref": "#/components/schemas/Any"
          }
        }
      },
      "ModelTraining": {
        "title": "ModelTraining",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "training_parameters": {
            "$ref": "#/components/schemas/Any"
          }
        }
      },
      "MoveEntityValueRequest": {
        "title": "MoveEntityValueRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID of the entity value to update"
          },
          "entity_value_id": {
            "type": "string",
            "description": "Entity value id to move"
          },
          "dest_entity_id": {
            "type": "string",
            "description": "Entity ID of the destination"
          }
        }
      },
      "MoveEntityValueResponse": {
        "title": "MoveEntityValueResponse",
        "properties": {
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          }
        }
      },
      "MoveEntityValueSynonymsRequest": {
        "title": "MoveEntityValueSynonymsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook."
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity_id": {
            "type": "string",
            "description": "The entity under which the entity value referenced by entity_value_id is located."
          },
          "entity_value_id": {
            "type": "string",
            "description": "The entity value under which the synonyms to move are located."
          },
          "synonym_values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of synonyms values to move."
          },
          "before_synonym_value": {
            "type": "string",
            "description": "If specified, move the synonym to a position before the specified synonym value. May reposition subsequent synonyms on collision."
          },
          "after_synonym_value": {
            "type": "string",
            "description": "If specified, move the synonym to a position after the specified synonym value. May reposition subsequent synonyms on collision."
          },
          "to_position": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        }
      },
      "MoveEntityValueSynonymsResponse": {
        "title": "MoveEntityValueSynonymsResponse",
        "properties": {
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          }
        }
      },
      "MoveEntityValuesRequest": {
        "title": "MoveEntityValuesRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook."
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity_id": {
            "type": "string",
            "description": "The entity under which the entity values to move are located."
          },
          "entity_value_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of entity value ids to move."
          },
          "dest_entity_id": {
            "type": "string",
            "description": "If specified, move the entity values to the given entity."
          },
          "before_entity_value_id": {
            "type": "string",
            "description": "If specified, move the entity value to a position before the specified entity value id. May reposition subsequent entity values on collision."
          },
          "after_entity_value_id": {
            "type": "string",
            "description": "If specified, move the entity value to a position after the specified entity value id. May reposition subsequent entity values on collision."
          },
          "to_position": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "append": {
            "type": "boolean",
            "description": "If specified, move the entity values to the end of the entity."
          }
        }
      },
      "MoveEntityValuesResponse": {
        "title": "MoveEntityValuesResponse",
        "properties": {
          "entity_values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityValue"
            }
          }
        }
      },
      "MoveIntentsRequest": {
        "title": "MoveIntentsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook."
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of intent ids to move."
          },
          "parent_intent_id": {
            "type": "string",
            "description": "The parentId value to affect to the intent after the move operation. If this field is omitted, it will be set to NULL."
          },
          "before_intent_id": {
            "type": "string",
            "description": "If specified, moves the intent to a position before the specified intent id. May reposition subsequent intents on collision."
          },
          "after_intent_id": {
            "type": "string",
            "description": "If specified, moves the intent to a position after the specified intent id. May reposition subsequent intents on collision."
          },
          "to_position": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        }
      },
      "MoveIntentsResponse": {
        "title": "MoveIntentsResponse",
        "properties": {
          "intents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Intent"
            }
          }
        }
      },
      "MoveTrainingPhraseRequest": {
        "title": "MoveTrainingPhraseRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "phrase_id": {
            "type": "string",
            "description": "ID of the phrase to update"
          },
          "from_intent_id": {
            "type": "string",
            "description": "ID of the intent from which we move the phrase from"
          },
          "to_intent_id": {
            "type": "string",
            "description": "ID of the intent to which we move phrase to"
          },
          "to_negative": {
            "type": "boolean",
            "description": "Move the phrase to intent `to_intent_id` negative list Move the phrase to intent `to_intent_id` negative list Move the phrase to intent `to_intent_id` negative list"
          },
          "override_protection": {
            "type": "boolean",
            "description": "Override protection on phrases"
          }
        }
      },
      "MoveTrainingPhraseResponse": {
        "title": "MoveTrainingPhraseResponse",
        "properties": {
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          }
        }
      },
      "NlgModelParameters": {
        "title": "NlgModelParameters",
        "properties": {
          "model_name": {
            "type": "string",
            "description": "The LLM model to use for completions. Deprecated in favour of `models`"
          },
          "models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NlgModelRef"
            },
            "description": "The LLM model to use, in order of priority. Later models will be used as a fallback, should the earlier model have an insufficient context window."
          },
          "temperature": {
            "type": "number",
            "description": "Temperature setting for prompt completions.",
            "format": "float"
          },
          "max_tokens": {
            "type": "integer",
            "description": "Max number of tokens allowed between the prompt and completion.",
            "format": "int32"
          },
          "top_p": {
            "type": "number",
            "description": "Top p setting for prompt completions. Should be a value between 0 and 1.",
            "format": "float"
          },
          "frequency_penalty": {
            "type": "number",
            "description": "Frequency penalty setting for prompt completions.",
            "format": "float"
          },
          "presence_penalty": {
            "type": "number",
            "description": "Presence penalty setting for prompt completions.",
            "format": "float"
          },
          "stop_sequences": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Configured stop sequences to tell the LLM when to stop generating text in the completion. For OpenAI, only up to the first 4 stop sequences will be used."
          }
        }
      },
      "NlgModelRef": {
        "title": "NlgModelRef",
        "properties": {
          "integration_id": {
            "type": "string",
            "description": "[Optional] Integration hosting this model. If unset, the namespace's only  LLM integration will be used. If multiple integrations are present, this field must be set."
          },
          "model_name": {
            "type": "string",
            "description": "Model name to use for generations"
          }
        }
      },
      "NlgSettings": {
        "title": "NlgSettings",
        "properties": {
          "integration_id": {
            "type": "string",
            "description": "The id of the integration to use for the NLG prompt completions."
          },
          "conversation_set_id": {
            "type": "string",
            "description": "The conversation set to use to store NLG prompt completions. It is expected that the first conversation source in the conversation set is a user upload source."
          },
          "generation_id": {
            "type": "integer",
            "description": "An incrementing id that is asscoiated to each prompt completion attempt in recommendations.",
            "format": "uint32"
          },
          "prompt_template": {
            "type": "string",
            "description": "The template to inject an intent's specific prompt into. The prompt will interpolate `$INTENT_PROMPT` and `$EXAMPLE_TEXT` within the prompt based on provided data."
          },
          "intent_prompt_metadata_key": {
            "type": "string",
            "description": "The metadata key to reference to extract the an intent's prompt. If this is empty, a fallback key of \"hint\" will be used."
          },
          "model_name": {
            "type": "string",
            "description": "The LLM model to use for openai prompt completions. Deprecated in favor of `model_parameters.model_name`. Is in sync with `model_parameters.model_name`, taking its value. If updated, the model parameters will be updated as well."
          },
          "temperature": {
            "type": "number",
            "description": "Temperature setting for prompt completions. Deprecated in favor of `model_parameters.temperature`. Is in sync with `model_parameters.temperature`, taking its value. If updated, the model parameters will be updated as well.",
            "format": "float"
          },
          "max_tokens": {
            "type": "integer",
            "description": "Max number of tokens allowed between the prompt and completion. Deprecated in favor of `model_parameters.max_tokens`. Is in sync with `model_parameters.max_tokens`, taking its value. If updated, the model parameters will be updated as well.",
            "format": "int32"
          },
          "top_p": {
            "type": "number",
            "description": "Top p setting for prompt completions. Should be a value between 0 and 1. Deprecated in favor of `model_parameters.top_p`. Is in sync with `model_parameters.top_p`, taking its value. If updated, the model parameters will be updated as well.",
            "format": "float"
          },
          "frequency_penalty": {
            "type": "number",
            "description": "Frequency penalty setting for prompt completions. Deprecated in favor of `model_parameters.frequency_penalty`. Is in sync with `model_parameters.frequency_penalty`, taking its value. If updated, the model parameters will be updated as well.",
            "format": "float"
          },
          "presence_penalty": {
            "type": "number",
            "description": "Presence penalty setting for prompt completions. Deprecated in favor of `model_parameters.presence_penalty`. Is in sync with `model_parameters.presence_penalty`, taking its value. If updated, the model parameters will be updated as well.",
            "format": "float"
          },
          "stop_sequences": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Configured stop sequences to tell the LLM when to stop generating text in the completion. Deprecated in favor of `model_parameters.stop_sequences`. For OpenAI, only up to the first 4 stop sequences will be used. Is in sync with `model_parameters.stop_sequences`, taking its value. If updated, the model parameters will be updated as well."
          },
          "model_parameters": {
            "$ref": "#/components/schemas/NlgModelParameters"
          }
        }
      },
      "NluEngineCustom": {
        "title": "NluEngineCustom",
        "properties": {}
      },
      "NluEngineDialogflowCx": {
        "title": "NluEngineDialogflowCx",
        "properties": {
          "project_id": {
            "type": "string",
            "description": "GCP project of the agent. If empty, default project in the integration will be used."
          },
          "location": {
            "type": "string",
            "description": "GCP location of the agent (ex: northamerica-northeast1) If empty, default project in the integration will be used, otherwise global is used."
          },
          "credential_id": {
            "type": "string",
            "description": "The id of the GCP credential to use. Deprecated. It was replaced by [NluSettings.integration_id]"
          },
          "model_type": {
            "type": "integer",
            "description": "DialogFlow NLU model type. See https://cloud.google.com/dialogflow/cx/docs/concept/agent",
            "format": "enum"
          }
        }
      },
      "NluEngineHuggingFace": {
        "title": "NluEngineHuggingFace",
        "properties": {
          "base_model": {
            "type": "string",
            "description": "The base model to start from. See https://huggingface.co/models The model needs to use a supported architecture and support TensorFlow (currently) e.g `bert-base-uncased`"
          },
          "config_json": {
            "type": "string",
            "description": "(Optional) A json configuration to be merged with the base model's default configuration"
          },
          "training_args_json": {
            "type": "string",
            "description": "(Optional) A json object containing training (hyper-) parameters"
          }
        }
      },
      "NluEngineInternal": {
        "title": "NluEngineInternal",
        "properties": {
          "latent_space_key": {
            "type": "string",
            "description": "(Optional) Specify the latent space to use when training this engine"
          }
        }
      },
      "NluEngineRasa": {
        "title": "NluEngineRasa",
        "properties": {
          "pipeline_config": {
            "type": "string",
            "description": "Contents of the `config.yml` to be used for training"
          }
        }
      },
      "NluSettings": {
        "title": "NluSettings",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of the NLU engine in the workspace."
          },
          "name": {
            "type": "string",
            "description": "(Optional) User defined name of the NLU engine. Since a user can have multiple NLU engines of the same type, this name is used to identify the engine in the UI."
          },
          "engine_version": {
            "type": "string",
            "description": "Version of the specified NLU engine. Since multiple deployments are feasible, this specifies the exact image which will be used when using an external NLU engine. This parameter has no impact for the `internal` engine."
          },
          "is_default": {
            "type": "boolean",
            "description": "Internally managed flag to indicate that this is the default engine of the workspace. This should not be modified via the API as it is enforced by the backend, unless set when calling `CreatePlaybookNluEngine` or `UpdatePlaybookNluEngine` to declare an engine as default."
          },
          "seq_id": {
            "type": "integer",
            "description": "Internally managed non-zero unique sequential number assigned to the engine. This should not be modified via the API as it is enforced by the backend.",
            "format": "uint32"
          },
          "on_demand_train": {
            "type": "boolean",
            "description": "Only allow training the NLU engine when it is explicitely triggered. Useful to prevent expensive NLU engines (ex: DialogFlow) from being triggered automatically."
          },
          "on_demand_infer": {
            "type": "boolean",
            "description": "Only allow using the NLU engine in unlabelled data inference if it's explicitely triggered to run."
          },
          "max_retry": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "integration_id": {
            "type": "string",
            "description": "(Optional) Unique identifier of the integration if the NLU engine is linked to an external integration."
          },
          "training_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          },
          "intent_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          },
          "hierarchical_remap_score": {
            "$ref": "#/components/schemas/BoolValue"
          },
          "internal": {
            "$ref": "#/components/schemas/NluEngineInternal"
          },
          "rasa": {
            "$ref": "#/components/schemas/NluEngineRasa"
          },
          "dialogflow_cx": {
            "$ref": "#/components/schemas/NluEngineDialogflowCx"
          },
          "huggingface": {
            "$ref": "#/components/schemas/NluEngineHuggingFace"
          },
          "custom": {
            "$ref": "#/components/schemas/NluEngineCustom"
          },
          "auto_train": {
            "type": "boolean",
            "description": "If true, training and inference of this NLU engine will be triggered automatically when the playbook is saved. The engine will run training and inference regardless of the `on_demand_train` and `on_demand_infer` flags."
          }
        }
      },
      "Operation": {
        "title": "Operation",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the operation was launched."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the operation."
          },
          "done": {
            "type": "boolean",
            "description": "Indicates that the operation has completed. If `error` is set, the operation has failed. Otherwise, the operation has succeeded and `result` may be set if the operation has a response."
          },
          "error": {
            "$ref": "#/components/schemas/Error"
          },
          "response": {
            "$ref": "#/components/schemas/Any"
          }
        }
      },
      "PhraseLocation": {
        "title": "PhraseLocation",
        "properties": {
          "conversation_id": {
            "type": "string",
            "description": "The conversation / context which contains the given spans"
          },
          "input_id": {
            "type": "string",
            "description": "The normalized input / example id from the pipeline"
          },
          "conversation_type": {
            "type": "integer",
            "description": "Type of conversation the phrase was found in. Numeric value of zia.ai.model.ConversationType",
            "format": "uint32"
          },
          "spans": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpanIndex"
            },
            "description": "The spans (conversation fragments) that represent this phrase. Multiple spans can be defined in the event where the relevant portions of text are separated."
          }
        }
      },
      "Pipeline": {
        "title": "Pipeline",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the pipeline."
          },
          "seq_id": {
            "type": "integer",
            "description": "Internally managed non-zero unique sequential number assigned to the pipeline. This should not be modified via the API as it is enforced by the backend.",
            "format": "uint32"
          },
          "name": {
            "type": "string",
            "description": "The name of the pipeline."
          },
          "steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PipelineStep"
            },
            "description": "The steps of the pipeline."
          },
          "last_generation_run_id": {
            "type": "integer",
            "description": "If non-zero, the id of the generation run from the last time this pipeline was run",
            "format": "uint32"
          }
        }
      },
      "PipelineStep": {
        "title": "PipelineStep",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the step."
          },
          "name": {
            "type": "string",
            "description": "The name of the step."
          },
          "data_query": {
            "$ref": "#/components/schemas/DataQuery"
          },
          "program": {
            "$ref": "#/components/schemas/Program"
          },
          "cumulative": {
            "type": "boolean",
            "description": "If set, always append generated data to the existing output instead of replacing it (default false)"
          }
        }
      },
      "PipelineTransform": {
        "title": "PipelineTransform",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "pipeline_id": {
            "type": "string"
          },
          "pipeline_step_id": {
            "type": "string"
          },
          "generation_run_id": {
            "type": "integer",
            "format": "uint32"
          }
        }
      },
      "Placeholder": {
        "title": "Placeholder",
        "properties": {
          "tag_id": {
            "type": "string",
            "description": "The tag identifier representing the type of agent response that would be created at this location. See [zia.ai.Playbook.Tag.id]"
          }
        }
      },
      "Playbook": {
        "title": "Playbook",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workspace."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the workspace generated by the server."
          },
          "name": {
            "type": "string",
            "description": "User visible given name of the workspace."
          },
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScopedReference"
            },
            "description": "Optional list of conversation sets ids that are to be included inside conversations"
          },
          "color": {
            "type": "string",
            "description": "Color of the playbook in the UI. Any CSS color format is supported (ex: #FF0000, red)."
          },
          "base_language": {
            "type": "string",
            "description": "Base language of the workspace. If empty, 'en' is assumed. 2 letters ISO 639-1 or BCP47 locale format (ex: 'en-US') deprecated: use `flags.languages.default_language`"
          },
          "active_languages": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Languages that can be used in the workspace, on top of the base language. 2 letters ISO 639-1 or BCP47 locale format (ex: 'en-US') deprecated: use `flags.languages.enabled_languages`"
          },
          "nlu": {
            "$ref": "#/components/schemas/NluSettings"
          },
          "other_nlus": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NluSettings"
            },
            "description": "Settings of other NLU engines that the workspace can use."
          },
          "evaluation": {
            "$ref": "#/components/schemas/EvaluationSettings"
          },
          "creation_time": {
            "type": "string",
            "description": "Time at which the playbook got created. Added in Feb 2021, so all playbook created before that won't have the field populated.",
            "format": "RFC3339"
          },
          "phrase_uniqueness_level": {
            "type": "integer",
            "description": "Determines the level of uniqueness allowed in the workspace. 0 = intent level (PHRASE_UNIQUENESS_LEVEL_INTENT): a phrase can only exist once within the intent it's associated to. 1 = workspace level (PHRASE_UNIQUENESS_LEVEL_WORKSPACE): a phrase can only exist once in the entire workspace. 2 = none (PHRASE_UNIQUENESS_LEVEL_NONE): a phrase can exist more than once, anywhere in the entire workspace.",
            "format": "enum"
          },
          "presets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Preset"
            },
            "description": "Stored settings to aid in providing easier repeatability of various behaviours of a workspace."
          },
          "metadata": {
            "$ref": "#/components/schemas/MetadataEntry"
          },
          "nlg": {
            "$ref": "#/components/schemas/NlgSettings"
          },
          "pipelines": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Pipeline"
            },
            "description": "Pipelines associated with this workspace."
          },
          "default_coverage_data": {
            "type": "integer",
            "description": "Default data selection to use for coverage report.",
            "format": "enum"
          },
          "manual_data_pipeline": {
            "type": "boolean",
            "description": "If true, a pipeline for manual data (ex: examples from stash) will be created."
          },
          "schema_id": {
            "type": "string",
            "description": "(Optional) ID of the schema used by the workspace."
          },
          "schema": {
            "$ref": "#/components/schemas/Schema"
          },
          "owner_id": {
            "type": "string",
            "description": "Optional user ID of the owner of the playbook."
          },
          "is_private": {
            "type": "boolean",
            "description": "Whether other users, outside the owner (and admins), have access to this playbook."
          }
        },
        "description": "Workspace"
      },
      "PlaybookClone": {
        "title": "PlaybookClone",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "source_namespace": {
            "type": "string"
          },
          "source_playbook_id": {
            "type": "string"
          },
          "source_playbook_revision_id": {
            "type": "string"
          }
        }
      },
      "PlaybookCreate": {
        "title": "PlaybookCreate",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          }
        }
      },
      "PlaybookRevision": {
        "title": "PlaybookRevision",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          }
        }
      },
      "PredictRequest": {
        "title": "PredictRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace where the workspace is located."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace whose model is to be used."
          },
          "input_utterance": {
            "type": "string",
            "description": "Input text to classify."
          },
          "model_id": {
            "type": "string",
            "description": "Optional. Specifies which model to use through its unique NLU engine identifier. If none specified, the default is used."
          },
          "revision_id": {
            "type": "string",
            "description": "Optional. Specifies which revision of the model to use."
          },
          "intent_tags": {
            "$ref": "#/components/schemas/TagPredicate"
          }
        }
      },
      "PredictResponse": {
        "title": "PredictResponse",
        "properties": {
          "matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntentMatch"
            },
            "description": "Raw list of matches ordered by descending score (no hierarchical considerations)"
          },
          "hier_matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HierIntentMatch"
            },
            "description": "List of matches rescored with hierarchical considerations."
          },
          "entity_matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityMatch"
            },
            "description": "Entity matches, if available"
          },
          "parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputPart"
            },
            "description": "If there are entity matches, matches in `part` format for convenience"
          },
          "model_id": {
            "type": "string",
            "description": "The model that was used to make this prediction."
          },
          "revision_id": {
            "type": "string",
            "description": "The revision of the model that was used to make this prediction."
          }
        }
      },
      "Preset": {
        "title": "Preset",
        "properties": {
          "id": {
            "type": "string",
            "description": "Id of the preset."
          },
          "seq_id": {
            "type": "integer",
            "description": "Internally managed non-zero unique sequential number assigned to the preset. This should not be modified via the API as it is enforced by the backend.",
            "format": "uint32"
          },
          "name": {
            "type": "string",
            "description": "Name of the preset."
          },
          "description": {
            "type": "string",
            "description": "Description of the preset."
          },
          "evaluation": {
            "$ref": "#/components/schemas/Evaluation"
          },
          "intents_export": {
            "$ref": "#/components/schemas/IntentsExport"
          },
          "intents_import": {
            "$ref": "#/components/schemas/IntentsImport"
          }
        },
        "description": "Stores configured settings for a particular behaviour within a workspace, in order to allow for easier and repeatable usage of various features and functionality. Reference the comments of each potential value of the `settings` field for each possible preset type and their intended usage."
      },
      "Processor": {
        "title": "Processor",
        "properties": {
          "key": {
            "type": "string"
          },
          "params": {
            "$ref": "#/components/schemas/ParamsEntry"
          }
        }
      },
      "Program": {
        "title": "Program",
        "properties": {
          "prompt_transform": {
            "$ref": "#/components/schemas/PromptTransform"
          }
        }
      },
      "Progress": {
        "title": "Progress",
        "properties": {
          "total": {
            "type": "integer",
            "description": "The number of items to complete.",
            "format": "uint64"
          },
          "completed": {
            "type": "integer",
            "description": "The number of items completed.",
            "format": "uint64"
          },
          "percentage_complete": {
            "type": "number",
            "description": "The percentage of progress complete. This is a value between .0 and 1.0. This number represents a more granular nature of the progress, where it may be possible that a particular work item is not completed, but making progress.",
            "format": "double"
          }
        }
      },
      "PromptTransform": {
        "title": "PromptTransform",
        "properties": {
          "prompt_id": {
            "type": "string",
            "description": "The unique identifier of the prompt to be used."
          }
        }
      },
      "Query": {
        "title": "Query",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/Any"
          },
          "extra_client_data": {
            "type": "string",
            "description": "Extra data to be saved by the client for use under its discretion."
          }
        }
      },
      "Rasa": {
        "title": "Rasa",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/MetadataEntry"
          }
        }
      },
      "ReferenceSource": {
        "title": "ReferenceSource",
        "properties": {
          "dialogflow": {
            "$ref": "#/components/schemas/Dialogflow"
          },
          "rasa": {
            "$ref": "#/components/schemas/Rasa"
          }
        }
      },
      "RegexKind": {
        "title": "RegexKind",
        "properties": {}
      },
      "RemapEntityReferencesRequest": {
        "title": "RemapEntityReferencesRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity_id": {
            "type": "string",
            "description": "Entity of the entity value to remap from Deprecated: use `remappings` instead"
          },
          "value_id": {
            "type": "string",
            "description": "Entity value to remap from Deprecated: use `remappings` instead"
          },
          "synonym": {
            "type": "string",
            "description": "(Optional) Limit the remapping to references that use a specific synonym. Deprecated: use `remappings` instead"
          },
          "to_entity_id": {
            "type": "string",
            "description": "Entity of the entity value to remap to Deprecated: use `remappings` instead"
          },
          "to_value_id": {
            "type": "string",
            "description": "Entity value to remap to Deprecated: use `remappings` instead"
          },
          "remappings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Remapping"
            }
          }
        }
      },
      "RemapEntityReferencesResponse": {
        "title": "RemapEntityReferencesResponse",
        "properties": {
          "remapped_count": {
            "type": "integer",
            "description": "Number of remapped references.",
            "format": "uint32"
          },
          "background_operation": {
            "$ref": "#/components/schemas/Operation"
          }
        }
      },
      "Remapping": {
        "title": "Remapping",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Entity of the entity value to remap from"
          },
          "value_id": {
            "type": "string",
            "description": "Entity value to remap from"
          },
          "synonym": {
            "type": "string",
            "description": "(Optional) Limit the remapping to references that use a specific synonym."
          },
          "to_entity_id": {
            "type": "string",
            "description": "Entity of the entity value to remap to"
          },
          "to_value_id": {
            "type": "string",
            "description": "Entity value to remap to"
          },
          "intent_id": {
            "type": "string",
            "description": "Intent to scope the remapping changes to"
          }
        }
      },
      "Run": {
        "title": "Run",
        "properties": {
          "id": {
            "type": "integer",
            "description": "The id of the nlg generation run.",
            "format": "uint32"
          },
          "prompt_id": {
            "type": "string",
            "description": "The prompt id of the nlg generation run if it was triggered by a prompt."
          },
          "pipeline_id": {
            "type": "string",
            "description": "The pipeline id of the nlg generation run if it was triggered by a pipeline."
          },
          "created_at": {
            "type": "string",
            "description": "Timestamp when the nlg generation run was created.",
            "format": "RFC3339"
          },
          "completed_at": {
            "type": "string",
            "description": "Timestamp when the nlg generation run was completed.",
            "format": "RFC3339"
          },
          "statistics": {
            "$ref": "#/components/schemas/GenerationRunStatistics"
          }
        }
      },
      "ScheduleStrategy": {
        "title": "ScheduleStrategy",
        "properties": {
          "num_hours": {
            "$ref": "#/components/schemas/ScheduleStrategyNumHours"
          },
          "once_a_day": {
            "$ref": "#/components/schemas/ScheduleStrategyOnceADay"
          },
          "once_a_week": {
            "$ref": "#/components/schemas/ScheduleStrategyOnceAWeek"
          },
          "once_a_month": {
            "$ref": "#/components/schemas/ScheduleStrategyOnceAMonth"
          }
        }
      },
      "ScheduleStrategyNumHours": {
        "title": "ScheduleStrategyNumHours",
        "properties": {
          "num_hours": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        }
      },
      "ScheduleStrategyOnceADay": {
        "title": "ScheduleStrategyOnceADay",
        "properties": {
          "hour": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "minute": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        },
        "description": "Run the import every day at the specified time."
      },
      "ScheduleStrategyOnceAMonth": {
        "title": "ScheduleStrategyOnceAMonth",
        "properties": {
          "day_of_month": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "hour": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "minute": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        },
        "description": "Run the import once a month at the specified time."
      },
      "ScheduleStrategyOnceAWeek": {
        "title": "ScheduleStrategyOnceAWeek",
        "properties": {
          "day_of_week": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "hour": {
            "$ref": "#/components/schemas/UInt32Value"
          },
          "minute": {
            "$ref": "#/components/schemas/UInt32Value"
          }
        },
        "description": "Run the import once a week at the specified time."
      },
      "Schema": {
        "title": "Schema",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          },
          "mappers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Mapper"
            },
            "description": "Defines mappers that are used by fields of the schema. Mappers are used to transform values of fields into a different representation. One use case is to transform a string field into integer numbers for faster aggregations and joins."
          },
          "created_at": {
            "type": "string",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "format": "RFC3339"
          }
        },
        "description": "Custom / user defined schema for a dataset and/or workspace."
      },
      "SchemaChange": {
        "title": "SchemaChange",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "playbook_id": {
            "type": "string"
          },
          "conversation_set_id": {
            "type": "string"
          }
        }
      },
      "ScopedReference": {
        "title": "ScopedReference",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the referenced object."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the referenced object."
          }
        }
      },
      "SearchEntityValueResponse": {
        "title": "SearchEntityValueResponse",
        "properties": {
          "entity_values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityValue"
            },
            "description": "A list of matching entity values, in order of relevance."
          }
        }
      },
      "SearchIntentResponse": {
        "title": "SearchIntentResponse",
        "properties": {
          "intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of matching intents, in order of relevance"
          }
        }
      },
      "SetEntitySettingsRequest": {
        "title": "SetEntitySettingsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook."
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity_id": {
            "type": "string",
            "description": "Id of the entity to set intent settings on."
          },
          "allowed_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The explicit list of intent ids that are permitted for this entity to be attached to."
          },
          "denied_intent_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The explicit list of intent ids that are not permitted for this entity to be attached to."
          }
        }
      },
      "SetEntitySettingsResponse": {
        "title": "SetEntitySettingsResponse",
        "properties": {}
      },
      "Source": {
        "title": "Source",
        "properties": {
          "conversation_source_id": {
            "type": "string",
            "description": "Unique identifier of the conversation source which has synchronized the raw conversations."
          }
        },
        "description": "Describe a source of the conversation set."
      },
      "Span": {
        "title": "Span",
        "properties": {
          "start": {
            "type": "integer",
            "description": "The start of this entity, as the utf8 byte index",
            "format": "uint32"
          },
          "end": {
            "type": "integer",
            "description": "The end of this entity, as the utf8 byte index",
            "format": "uint32"
          }
        }
      },
      "SpanIndex": {
        "title": "SpanIndex",
        "properties": {
          "start": {
            "$ref": "#/components/schemas/SpanPosition"
          },
          "end": {
            "$ref": "#/components/schemas/SpanPosition"
          }
        }
      },
      "SpanPosition": {
        "title": "SpanPosition",
        "properties": {
          "input_index": {
            "type": "integer",
            "description": "The index of the input the span refers to. This index is inclusive on both start and end positions. Ex: input 0 + input 1 => start=0, end=1",
            "format": "uint32"
          },
          "character_index": {
            "type": "integer",
            "description": "The byte index of the input. This index is inclusive on the start position, and exclusive on the end position. Ex: hello world, span of 'hello' => start=0, end=5, span of 'world' => start=6, end=11 Caution: When using encoding in which multiple bytes may represent a single displayable character (e.g. UTF-8, emojis), the byte index should enclose all bytes that make up the displayable character.",
            "format": "uint32"
          }
        }
      },
      "String": {
        "title": "String",
        "properties": {
          "full_text": {
            "type": "boolean",
            "description": "Enable full text indexation for the field."
          },
          "mapper": {
            "type": "string",
            "description": "If specified, the field will be mapped using the specified mapper. This is used to transform values of the field into a different representation. One use case is to transform a string field into integer numbers for faster aggregations and joins."
          }
        }
      },
      "SystemEntity": {
        "title": "SystemEntity",
        "properties": {
          "system_type": {
            "type": "integer",
            "description": "Unique type of the system entity",
            "format": "enum"
          },
          "key": {
            "type": "string",
            "description": "Key of the system entity"
          },
          "local_entity": {
            "$ref": "#/components/schemas/Entity"
          }
        }
      },
      "SystemKind": {
        "title": "SystemKind",
        "properties": {
          "well_known_type": {
            "type": "integer",
            "description": "Type of the system entity if it's part of the well known types supported by HumanFirst. Otherwise, `unknown` should be used an `other_type` filled in with the external NLU type name. (ex: sys.flight-number on DialogFlow)",
            "format": "enum"
          },
          "other_type": {
            "type": "string",
            "description": "For external NLUs, if the system entity type is not defined in the well known types, this should be filled with the type in the external NLU (ex: sys.flight-number in DialogFlow)"
          }
        }
      },
      "Tag": {
        "title": "Tag",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of the tag."
          },
          "name": {
            "type": "string",
            "description": "Name of the tag."
          },
          "description": {
            "type": "string",
            "description": "Description of the tag."
          },
          "color": {
            "type": "string",
            "description": "Color of the tag in the UI. Any CSS color format is supported (ex: #FF0000, red)."
          },
          "protected": {
            "type": "boolean",
            "description": "Indicates that any object with this tag cannot be modified without explicit confirmation."
          },
          "protected_recursive": {
            "type": "boolean",
            "description": "Indicates that any object with this tag, and their children cannot be modified without explicit confirmation. Ex: intent tagged with `protected_recursive` will also have their phrases protected"
          },
          "source": {
            "$ref": "#/components/schemas/TagSource"
          },
          "created_at": {
            "type": "string",
            "description": "Creation date of the tag",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "description": "(Optional) Update date of the tag",
            "format": "RFC3339"
          },
          "deleted_at": {
            "type": "string",
            "description": "(Optional) Deletion date of the tag",
            "format": "RFC3339"
          }
        }
      },
      "TagPredicate": {
        "title": "TagPredicate",
        "properties": {
          "require_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Only include objects with ALL of the given tag ids."
          },
          "include_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Only include objects with ANY of the given tag ids."
          },
          "exclude_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Exclude objects with ANY of the given tag ids."
          }
        }
      },
      "TagReference": {
        "title": "TagReference",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of the tag."
          },
          "name": {
            "type": "string",
            "description": "(Optional) Only used when importing data that tag IDs are not defined yet. This will not be filled when requesting tagged objects."
          },
          "protected": {
            "type": "boolean",
            "description": "For internal use. There is no guarantee that this will be properly filled."
          }
        }
      },
      "TagSource": {
        "title": "TagSource",
        "properties": {
          "source_id": {
            "type": "string",
            "description": "ID of the tag at its source if it has been imported (if applicable)"
          },
          "merged_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of unique identifiers of tags from HumanFirst or external integrations that got merged into this tag at some point and that can be reused to ease further merges. This list may not be exhaustive and could be truncated."
          },
          "dialogflow_cx": {
            "$ref": "#/components/schemas/DialogflowCx"
          },
          "dialogflow_es": {
            "$ref": "#/components/schemas/DialogflowEs"
          }
        }
      },
      "TemplateIntentInfo": {
        "title": "TemplateIntentInfo",
        "properties": {
          "template_id": {
            "type": "string",
            "description": "Template from which this intent was imported"
          },
          "template_name": {
            "type": "string"
          },
          "template_intent_id": {
            "type": "string",
            "description": "intent id within the template"
          },
          "parent_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of parents, from top to bottom"
          },
          "template_intent_name": {
            "type": "string",
            "description": "Original intent name, in the template"
          }
        }
      },
      "TestSet": {
        "title": "TestSet",
        "properties": {
          "phrase_tag_predicate": {
            "$ref": "#/components/schemas/TagPredicate"
          }
        }
      },
      "Text": {
        "title": "Text",
        "properties": {
          "text": {
            "type": "string"
          }
        }
      },
      "ThreadFileDeletion": {
        "title": "ThreadFileDeletion",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          },
          "thread_id": {
            "type": "string"
          }
        }
      },
      "ThreadFileUpload": {
        "title": "ThreadFileUpload",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "conversation_source_id": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          },
          "thread_id": {
            "type": "string"
          }
        }
      },
      "Timestamp": {
        "title": "Timestamp",
        "properties": {
          "not_stored": {
            "type": "boolean"
          }
        }
      },
      "TrainingPhrase": {
        "title": "TrainingPhrase",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier"
          },
          "translated_from_id": {
            "type": "string",
            "description": "If this training phrase is a translation of an original training phrase, ID of the TrainingPhrase from which this training phrase was translated from."
          },
          "text": {
            "type": "string",
            "description": "Verbatim text. In case of a fragment, copies the first user input"
          },
          "processed": {
            "type": "boolean",
            "description": "Whether this fragment has been been seen in the bottom-up response creation flow"
          },
          "constituents": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The divided sentences/constituents order to support multi-part."
          },
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PhraseLocation"
            },
            "description": "Editing a training phrase *appends* new locations."
          },
          "fragment": {
            "$ref": "#/components/schemas/Fragment"
          },
          "metadata": {
            "$ref": "#/components/schemas/TrainingPhraseMetadata"
          },
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputEntity"
            },
            "description": "Entities referenced in the training phrase `text`. If the `parts` field is provided on creation or update, this field is ignored and rebuilt from `parts`."
          },
          "parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputPart"
            },
            "description": "If the training phrase contains entities, this field contains the parts of the text and the entities. The parts are concatenated to form the final text. Parts are provided to ease entity annotations. If provided at creation or update, this will override the `entities` field."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagReference"
            },
            "description": "Tags of the phrase."
          },
          "source": {
            "type": "integer",
            "description": "Source of the training phrase",
            "format": "enum"
          },
          "source_info": {
            "$ref": "#/components/schemas/TrainingPhraseSourceInfo"
          },
          "created_at": {
            "type": "string",
            "description": "Date at which first the training phrase insert was done in database (generated by server)",
            "format": "RFC3339"
          },
          "updated_at": {
            "type": "string",
            "description": "Date at which last update to training phrase was done in database (generated by server)",
            "format": "RFC3339"
          },
          "deleted_at": {
            "type": "string",
            "description": "If present, the date at which the training phrase was deleted from the database (generated by server)",
            "format": "RFC3339"
          },
          "language": {
            "type": "string",
            "description": "Language of the training phrase. If empty, 'en' is assumed. 2 letters ISO 639-1 or BCP47 locale format (ex: 'en-US')."
          },
          "training_phrase_list": {
            "type": "string",
            "description": "If training phrase is stored in a database, list in which this phrase is."
          },
          "hash": {
            "type": "string",
            "description": "Hash of the normalized text of the phrase, used to join embeddings data."
          },
          "negative": {
            "type": "boolean",
            "description": "If the training phrase is associated to an intent, this indicates that it's a negative phrase"
          },
          "edited": {
            "type": "boolean",
            "description": "Whether this phrase's text prop has been modified from its original version"
          },
          "starred": {
            "type": "boolean"
          }
        }
      },
      "TrainingPhraseMetadata": {
        "title": "TrainingPhraseMetadata",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/MetadataEntry"
          }
        }
      },
      "TrainingPhraseMetadataKey": {
        "title": "TrainingPhraseMetadataKey",
        "properties": {
          "type": {
            "type": "integer",
            "format": "enum"
          },
          "key": {
            "type": "string"
          }
        }
      },
      "TrainingPhraseSourceInfo": {
        "title": "TrainingPhraseSourceInfo",
        "properties": {
          "source_id": {
            "type": "string",
            "description": "ID of the training phrase at its source (if applicable)"
          },
          "merged_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of unique identifiers of phrase from HumanFirst or external integrations that got merged into this phrase at some point and that can be reused to ease further merges. This list may not be exhaustive and could be truncated."
          },
          "botpress": {
            "$ref": "#/components/schemas/Botpress"
          },
          "rasa": {
            "$ref": "#/components/schemas/Rasa"
          },
          "dialogflow": {
            "$ref": "#/components/schemas/Dialogflow"
          }
        }
      },
      "Trigger": {
        "title": "Trigger",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the trigger."
          },
          "entry_point": {
            "type": "string",
            "description": "First job that got triggered."
          },
          "message": {
            "type": "string",
            "description": "Message associated with the trigger."
          },
          "author_email": {
            "type": "string",
            "description": "Author email of the trigger."
          },
          "author_user_id": {
            "type": "string",
            "description": "Author user id of the trigger."
          },
          "pinned": {
            "type": "boolean",
            "description": "Pinned signals that all job runs related to this trigger should be preserved if they still exist."
          },
          "cancelled": {
            "type": "boolean",
            "description": "Signals if the trigger has been cancelled. Some jobs may not have run because of this cancellation."
          },
          "data": {
            "$ref": "#/components/schemas/DataEntry"
          },
          "metadata": {
            "$ref": "#/components/schemas/JobTriggerMetadata"
          },
          "created_at": {
            "type": "string",
            "description": "The time that the trigger was created.",
            "format": "RFC3339"
          },
          "completed_at": {
            "type": "string",
            "description": "The time at which the last required node for the trigger has completed a successful run. A trigger is only complete once all required node have successfully ran or have been skipped.",
            "format": "RFC3339"
          },
          "failed_at": {
            "type": "string",
            "description": "The time at which the trigger has failed. A trigger is considered failed when there are too many consecutive failures in one of the required nodes.",
            "format": "RFC3339"
          }
        }
      },
      "TriggerPlaybookEphemeralPipelineRequest": {
        "title": "TriggerPlaybookEphemeralPipelineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the pipeline exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the pipeline exists."
          },
          "data_query": {
            "$ref": "#/components/schemas/DataQuery"
          },
          "program": {
            "$ref": "#/components/schemas/Program"
          }
        }
      },
      "TriggerPlaybookPipelineRequest": {
        "title": "TriggerPlaybookPipelineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the pipeline exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the pipeline exists."
          },
          "pipeline_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline."
          }
        }
      },
      "TriggerPlaybookPipelineResponse": {
        "title": "TriggerPlaybookPipelineResponse",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Generated trigger id, which can be retrieved in job runs"
          },
          "generation_run_id": {
            "type": "integer",
            "description": "The generation run id of the triggered pipeline",
            "format": "uint32"
          }
        }
      },
      "TriggerState": {
        "title": "TriggerState",
        "properties": {
          "trigger": {
            "$ref": "#/components/schemas/Trigger"
          },
          "jobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggeredJob"
            },
            "description": "All jobs that are related to the trigger."
          },
          "status": {
            "type": "integer",
            "description": "The current status of the trigger.",
            "format": "enum"
          },
          "progress": {
            "$ref": "#/components/schemas/Progress"
          }
        }
      },
      "TriggeredJob": {
        "title": "TriggeredJob",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the job."
          },
          "kind": {
            "type": "integer",
            "description": "The kind of job.",
            "format": "enum"
          },
          "triggered_run": {
            "$ref": "#/components/schemas/TriggeredJobRun"
          },
          "progress": {
            "$ref": "#/components/schemas/Progress"
          }
        }
      },
      "TriggeredJobRun": {
        "title": "TriggeredJobRun",
        "properties": {
          "run_id": {
            "type": "string",
            "description": "The unique identifier of the run."
          },
          "status": {
            "type": "integer",
            "description": "The current status of the job.",
            "format": "enum"
          },
          "start_time": {
            "type": "string",
            "description": "The time the job was started.",
            "format": "RFC3339"
          },
          "end_time": {
            "type": "string",
            "description": "The time the job was completed.",
            "format": "RFC3339"
          },
          "error": {
            "type": "string",
            "description": "The error message if the job failed."
          },
          "error_details": {
            "$ref": "#/components/schemas/ErrorDetails"
          },
          "consecutive_failures": {
            "type": "integer",
            "description": "The number of consecutive failures.",
            "format": "uint32"
          }
        }
      },
      "Type": {
        "title": "Type",
        "properties": {
          "kind": {
            "type": "integer",
            "format": "enum"
          }
        }
      },
      "UInt32Value": {
        "title": "UInt32Value",
        "properties": {
          "value": {
            "type": "integer",
            "description": "The uint32 value.",
            "format": "uint32"
          }
        },
        "description": "Wrapper message for `uint32`. The JSON representation for `UInt32Value` is JSON number."
      },
      "UniqueUtteranceHierScoreHistogramEntry": {
        "title": "UniqueUtteranceHierScoreHistogramEntry",
        "properties": {
          "key": {
            "type": "integer",
            "format": "uint32"
          },
          "value": {
            "type": "integer",
            "format": "uint32"
          }
        }
      },
      "UniqueUtteranceScoreHistogramEntry": {
        "title": "UniqueUtteranceScoreHistogramEntry",
        "properties": {
          "key": {
            "type": "integer",
            "format": "uint32"
          },
          "value": {
            "type": "integer",
            "format": "uint32"
          }
        }
      },
      "UnlinkConversationSetsRequest": {
        "title": "UnlinkConversationSetsRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation sets and workspace are."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "conversation_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Unique identifiers of the conversation sets to unlink. Deprecated: Use conversation_sets instead. If conversation_set_ids is specified, ids will be converted to conversation_sets `namespace` used as the associated namespace."
          },
          "conversation_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScopedReference"
            },
            "description": "The conversation sets to unlink."
          }
        }
      },
      "UnlinkConversationSetsResponse": {
        "title": "UnlinkConversationSetsResponse",
        "properties": {
          "trigger_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline trigger that was created when unlinking the conversation sets. If there are no resulting changes to the list of linked conversation sets, this will be empty."
          }
        }
      },
      "UpdateConversationSetConfigurationRequest": {
        "title": "UpdateConversationSetConfigurationRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation set is."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation set."
          },
          "config": {
            "$ref": "#/components/schemas/ConversationSetConfiguration"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateConversationSetRequest": {
        "title": "UpdateConversationSetRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation set is."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation set."
          },
          "conversation_set": {
            "$ref": "#/components/schemas/ConversationSet"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateConversationSetStateRequest": {
        "title": "UpdateConversationSetStateRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation set is."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation set."
          },
          "conversation_set_state": {
            "$ref": "#/components/schemas/ConversationSetState"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateConversationSourceRequest": {
        "title": "UpdateConversationSourceRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which conversation source is."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the conversation source."
          },
          "conversation_source": {
            "$ref": "#/components/schemas/ConversationSource"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateEntityRequest": {
        "title": "UpdateEntityRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook."
          },
          "entity": {
            "$ref": "#/components/schemas/Entity"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "invert_update_mask": {
            "type": "boolean",
            "description": "If true, the update mask is inverted, meaning that all fields not specified in the mask will be updated."
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateEntityResponse": {
        "title": "UpdateEntityResponse",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/Entity"
          }
        }
      },
      "UpdateEntityValueRequest": {
        "title": "UpdateEntityValueRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID of the entity value to update"
          },
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Ignore mask and update all fields"
          }
        }
      },
      "UpdateEntityValueResponse": {
        "title": "UpdateEntityValueResponse",
        "properties": {
          "entity_value": {
            "$ref": "#/components/schemas/EntityValue"
          }
        }
      },
      "UpdateIntentRequest": {
        "title": "UpdateIntentRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent": {
            "$ref": "#/components/schemas/Intent"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          }
        }
      },
      "UpdatePlaybookNluEngineRequest": {
        "title": "UpdatePlaybookNluEngineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the nlu engine is."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the nlu engine is."
          },
          "nlu_id": {
            "type": "string",
            "description": "Unique identifier of the nlu engine."
          },
          "nlu_engine": {
            "$ref": "#/components/schemas/NluSettings"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask."
          }
        }
      },
      "UpdatePlaybookPipelineRequest": {
        "title": "UpdatePlaybookPipelineRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the pipeline exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the pipeline exists."
          },
          "pipeline_id": {
            "type": "string",
            "description": "Unique identifier of the pipeline."
          },
          "pipeline": {
            "$ref": "#/components/schemas/Pipeline"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask."
          }
        }
      },
      "UpdatePlaybookPresetRequest": {
        "title": "UpdatePlaybookPresetRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the preset exists."
          },
          "playbook_id": {
            "type": "string",
            "description": "Unique identifier of the workspace in which the preset exists."
          },
          "preset_id": {
            "type": "string",
            "description": "Unique identifier of the preset."
          },
          "preset": {
            "$ref": "#/components/schemas/Preset"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask."
          }
        }
      },
      "UpdatePlaybookRequest": {
        "title": "UpdatePlaybookRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace in which the workspace is."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "playbook": {
            "$ref": "#/components/schemas/Playbook"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          },
          "exclude_nlu_engines": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to nlu engines."
          },
          "exclude_presets": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to presets."
          },
          "exclude_pipelines": {
            "type": "boolean",
            "description": "Forces the exclusion of all fields related to pipelines."
          }
        }
      },
      "UpdatePlaybookStateRequest": {
        "title": "UpdatePlaybookStateRequest",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the workspace."
          },
          "playbook_state": {
            "$ref": "#/components/schemas/PlaybookState"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          }
        }
      },
      "UpdateTagRequest": {
        "title": "UpdateTagRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "tag": {
            "$ref": "#/components/schemas/Tag"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "If no mask specified, indicates that all fields need to be updated."
          }
        }
      },
      "UpdateTagResponse": {
        "title": "UpdateTagResponse",
        "properties": {
          "tag": {
            "$ref": "#/components/schemas/Tag"
          }
        }
      },
      "UpdateTrainingPhraseRequest": {
        "title": "UpdateTrainingPhraseRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "intent_id": {
            "type": "string",
            "description": "ID of the intent in which the phrase is"
          },
          "phrase_id": {
            "type": "string",
            "description": "ID of the phrase to update"
          },
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          },
          "override_protection": {
            "type": "boolean",
            "description": "Override protection on phrases"
          }
        }
      },
      "UpdateTrainingPhraseResponse": {
        "title": "UpdateTrainingPhraseResponse",
        "properties": {
          "phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          }
        }
      },
      "UpdateTrainingPhrasesRequest": {
        "title": "UpdateTrainingPhrasesRequest",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the playbook"
          },
          "playbook_id": {
            "type": "string",
            "description": "Metastore ID of the playbook"
          },
          "phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhrase"
            },
            "description": "Updated training phrases"
          },
          "update_mask": {
            "$ref": "#/components/schemas/FieldMask"
          },
          "update_all": {
            "type": "boolean",
            "description": "Forces the update of all fields without specifying a mask"
          },
          "override_protection": {
            "type": "boolean",
            "description": "Override protection on phrases"
          }
        }
      },
      "UpdateTrainingPhrasesResponse": {
        "title": "UpdateTrainingPhrasesResponse",
        "properties": {
          "phrases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingPhrase"
            },
            "description": "Updated phrases"
          }
        }
      },
      "UtteranceHierScoreHistogramEntry": {
        "title": "UtteranceHierScoreHistogramEntry",
        "properties": {
          "key": {
            "type": "integer",
            "format": "uint32"
          },
          "value": {
            "type": "integer",
            "format": "uint32"
          }
        }
      },
      "UtteranceScoreHistogramEntry": {
        "title": "UtteranceScoreHistogramEntry",
        "properties": {
          "key": {
            "type": "integer",
            "format": "uint32"
          },
          "value": {
            "type": "integer",
            "format": "uint32"
          }
        }
      },
      "ValidationProblem": {
        "title": "ValidationProblem",
        "properties": {
          "level": {
            "type": "integer",
            "description": "Level of the problem. 1 = Warning 2 = Fatal",
            "format": "enum"
          },
          "message": {
            "type": "string",
            "description": "Message of the problem."
          },
          "filename": {
            "type": "string",
            "description": "(Optional) Filename in which the problem was encountered."
          },
          "line": {
            "type": "integer",
            "description": "(Optional) Line of `filename` on which the problem was encountered.",
            "format": "uint32"
          },
          "training_phrase": {
            "$ref": "#/components/schemas/TrainingPhrase"
          },
          "intent": {
            "$ref": "#/components/schemas/Intent"
          }
        }
      },
      "ValuesEntry": {
        "title": "ValuesEntry",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/EntityValue"
          }
        }
      }
    }
  },
  "tags": [
    {
      "name": "Workspaces"
    },
    {
      "name": "Import / Export"
    },
    {
      "name": "NLU"
    }
  ],
  "servers": [
    {
      "url": "https://api.humanfirst.ai"
    }
  ],
  "security": [
    {
      "bearerAuth": []
    }
  ]
}